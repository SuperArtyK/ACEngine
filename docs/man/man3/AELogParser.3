.TH "AELogParser" 3 "Thu Feb 15 2024 11:57:32" "Version v0.0.8.5a" "ArtyK's Console Engine" \" -*- nroff -*-
.ad l
.nh
.SH NAME
AELogParser \- ArtyK's Engine's Log Parser; it parses the log files that \fBAELogger\fP writes\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fR#include <AELogParser\&.hpp>\fP
.PP
Inherits \fB__AEModuleBase< AELogParser >\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBAELogParser\fP (\fBvoid\fP)"
.br
.RI "Class constructor -- just initialises the object\&. "
.ti -1c
.RI "\fBAELogParser\fP (\fBconst\fP std::string_view \fBfname\fP)"
.br
.RI "Class constructor -- opens the file and start the indexing process\&. "
.ti -1c
.RI "\fB~AELogParser\fP (\fBvoid\fP)"
.br
.RI "Class destructor -- closes the log file\&. "
.ti -1c
.RI "\fBcint\fP \fBopenLog\fP (\fBconst\fP std::string_view \fBfname\fP)"
.br
.RI "Opens the log file, reading and parsing every single entry, classifying it by type\&. "
.ti -1c
.RI "\fBcint\fP \fBcloseLog\fP (\fBvoid\fP)"
.br
.RI "Closes the log file and clears the memory\&. "
.ti -1c
.RI "\fBcint\fP \fBnextEntry\fP (\fBAELogEntry\fP &\fBentry\fP, \fBconst\fP \fBcint\fP \fBseverity\fP=\fBAELOG_TYPE_DEBUG\fP, \fBconst\fP std::string_view \fBmname\fP='', \fBconst\fP bool \fBstrictSeverity\fP=\fBfalse\fP)"
.br
.RI "Read the next \fIvalid\fP entry in the log file of the given severity and module name filter, and parse it to the given \fBAELogEntry\fP object\&. "
.ti -1c
.RI "\fBcint\fP \fBnextEntryName\fP (\fBAELogEntry\fP &\fBentry\fP, \fBconst\fP std::string_view \fBmname\fP)"
.br
.RI "Read the next \fIvalid\fP entry in the log file of the given module name, and parse it into the given \fBAELogEntry\fP object\&. "
.ti -1c
.RI "\fBcint\fP \fBnextEntryType\fP (\fBAELogEntry\fP &\fBentry\fP, \fBconst\fP \fBcint\fP \fBseverity\fP, \fBconst\fP bool \fBstrictSeverity\fP=\fBfalse\fP)"
.br
.RI "Read the next \fIvalid\fP entry in the log file of the given severity, and parse it to the given \fBAELogEntry\fP object\&. "
.ti -1c
.RI "\fBcint\fP \fBnextEntryTypeStrict\fP (\fBAELogEntry\fP &\fBentry\fP, \fBconst\fP \fBcint\fP \fBseverity\fP)"
.br
.RI "Read the next \fIvalid\fP entry in the log file of the given severity, and parse it to the given \fBAELogEntry\fP object\&. "
.ti -1c
.RI "\fBllint\fP \fBnextEntryCursor\fP (\fBconst\fP \fBcint\fP \fBseverity\fP=\fBAELOG_TYPE_DEBUG\fP, \fBconst\fP std::string_view \fBmname\fP='', \fBconst\fP bool \fBstrictSeverity\fP=\fBfalse\fP)"
.br
.RI "Read the next indexed \fIvalid\fP log entry in the file of the given severity and module name filter, and return it's file cursors in the file\&. "
.ti -1c
.RI "\fBllint\fP \fBnextEntryCursorName\fP (\fBconst\fP std::string_view \fBmname\fP)"
.br
.RI "Read the next indexed \fIvalid\fP log entry in the file of the given module name filter, and return it's file cursors in the file\&. "
.ti -1c
.RI "\fBllint\fP \fBnextEntryCursorType\fP (\fBconst\fP \fBcint\fP \fBseverity\fP, \fBconst\fP bool \fBstrictSeverity\fP=\fBfalse\fP)"
.br
.RI "Read the next indexed \fIvalid\fP log entry in the file of the given severity filter and return it's file cursors in the file\&. "
.ti -1c
.RI "\fBllint\fP \fBnextEntryCursorTypeStrict\fP (\fBconst\fP \fBcint\fP \fBseverity\fP)"
.br
.RI "Read the next indexed \fIvalid\fP log entry in the file of the given severity filter and return it's file cursors in the file\&. "
.ti -1c
.RI "\fBllint\fP \fBcurrentEntryCursor\fP (\fBvoid\fP) \fBconst\fP \fBnoexcept\fP"
.br
.RI "Get the file cursors of the current valid entry This entry is the one that was read by a previous call to \fBAELogParser::nextEntry()\fP or AELogParser::getNextEntryIndex() "
.ti -1c
.RI "std::size_t \fBgetCurrentEntryIndex\fP (\fBvoid\fP) \fBconst\fP \fBnoexcept\fP"
.br
.RI "Return the order number (index) of the current log entry (that was just read) "
.ti -1c
.RI "\fBcint\fP \fBsetNextEntryIndex\fP (\fBconst\fP std::size_t \fBentryIndex\fP) \fBnoexcept\fP"
.br
.RI "Set the order number (index) of the next log entry to be parsed\&. "
.ti -1c
.RI "std::vector< \fBAELogEntryInfo\fP > \fBgetValidEntryCursorAll\fP (\fBvoid\fP) \fBconst\fP \fBnoexcept\fP"
.br
.RI "Get the list of file cursors of the valid entries, separated by type\&. "
.ti -1c
.RI "std::vector< \fBllint\fP > \fBgetInvalidEntryCursorAll\fP (\fBvoid\fP) \fBconst\fP \fBnoexcept\fP"
.br
.RI "Get the list of file cursors of the invalid entries\&. "
.ti -1c
.RI "\fBcint\fP \fBlogToQueue\fP (\fBAELogEntry\fP *&\fBbegin\fP, \fBconst\fP \fBcint\fP \fBseverity\fP=\fBAELOG_TYPE_DEBUG\fP)"
.br
.RI "Same as the \fBAELogParser::nextEntry()\fP but on massive scale -- scans the whole log file and parses it to the freshly-allocated queue\&. "
.ti -1c
.RI "\fBullint\fP \fBamountValidEntries\fP (\fBconst\fP \fBcint\fP \fBseverity\fP=\fBAELOG_TYPE_DEBUG\fP) \fBconst\fP \fBnoexcept\fP"
.br
.RI "Get the amount of valid entries in the log (with optional lowest severity setting)\&. "
.ti -1c
.RI "\fBullint\fP \fBamountInvalidEntries\fP (\fBvoid\fP) \fBconst\fP \fBnoexcept\fP"
.br
.RI "Get the amount of invalid entries in the log\&. "
.ti -1c
.RI "\fBullint\fP \fBamountTypeEntries\fP (\fBconst\fP \fBcint\fP \fBseverity\fP) \fBconst\fP \fBnoexcept\fP"
.br
.RI "Get the amount of entries of a certain type/severity\&. "
.ti -1c
.RI "bool \fBisOpen\fP (\fBvoid\fP) \fBconst\fP \fBnoexcept\fP"
.br
.RI "Checks if the file is opened by the \fBAELogParser\fP\&. "
.ti -1c
.RI "bool \fBisClosed\fP (\fBvoid\fP) \fBconst\fP \fBnoexcept\fP"
.br
.RI "Checks if the file is closed by the \fBAELogParser\fP\&. "
.ti -1c
.RI "std::string \fBgetFullFileName\fP (\fBvoid\fP) \fBconst\fP \fBnoexcept\fP"
.br
.RI "Returns the full name of currently open file, including the relative path, if such was provided\&. "
.ti -1c
.RI "std::string \fBgetRelativePath\fP (\fBvoid\fP) \fBconst\fP"
.br
.RI "Returns the relative path of the opened file\&. "
.ti -1c
.RI "std::string \fBgetFileName\fP (\fBvoid\fP) \fBconst\fP"
.br
.RI "Returns the name of the opened file, devoid of the path\&. "
.ti -1c
.RI "std::string \fBgetFullPath\fP (\fBvoid\fP) \fBconst\fP"
.br
.RI "Returns the full, absolute path of the opened file\&. "
.ti -1c
.RI "\fBAEFileReader\fP & \fBgetFileReader\fP (\fBvoid\fP) \fBnoexcept\fP"
.br
.RI "Return the reference to the \fBAEFileReader\fP object of this instance of \fBAELogParser\fP\&. "
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "\fBstatic\fP \fBullint\fP \fBgetModuleAmount\fP (\fBvoid\fP) \fBnoexcept\fP"
.br
.RI "Returns the amount of instances of the module currently existing\&. "
.ti -1c
.RI "\fBstatic\fP \fBconstexpr\fP std::string_view \fBgetModuleName\fP (\fBvoid\fP) \fBnoexcept\fP"
.br
.RI "Returns the name of the registered module\&. "
.in -1c
.SS "Static Protected Attributes"

.in +1c
.ti -1c
.RI "\fBstatic\fP std::atomic< \fBullint\fP > \fBm_ullModulesAlive\fP"
.br
.RI "Amount of alive module instances\&. "
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "\fBAELogEntryInfo\fP \fBfindNextEntry\fP (\fBconst\fP \fBcint\fP \fBseverity\fP, \fBconst\fP std::string_view \fBmname\fP, \fBconst\fP bool \fBstrictSeverity\fP)"
.br
.RI "Finds the \fBAELogEntryInfo\fP corresponding to the next log entry with the specified severity and module name\&. "
.ti -1c
.RI "\fBconstexpr\fP bool \fBerrorFromAELEI\fP (\fBconst\fP \fBAELogEntryInfo\fP &\fBleInfo\fP) \fBconst\fP \fBnoexcept\fP"
.br
.RI "Determines the error codes from the invalid values in the passed \fBAELogEntryInfo\fP instance\&. "
.ti -1c
.RI "\fBREGISTER_MODULE\fP (\fBAELogParser\fP)"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "\fBAEFileReader\fP \fBm_frLogReader\fP"
.br
.RI "The file reader of the opened log file\&. "
.ti -1c
.RI "std::vector< \fBAELogEntryInfo\fP > \fBm_vecEntryIndices\fP"
.br
.RI "The list of all indexed \fIvalid\fP entries in the log file\&. "
.ti -1c
.RI "std::vector< \fBllint\fP > \fBm_vecInvalidEntryIndices\fP"
.br
.RI "The list of all indexed \fIinvalid\fP entries in the log file Each item contains their corresponding cursor position in the file\&. "
.ti -1c
.RI "std::unordered_map< std::string, short > \fBm_mapModuleNames\fP"
.br
.RI "The map of the all module names parsed in the log file\&. "
.ti -1c
.RI "std::array< \fBullint\fP, 9 > \fBm_arrEntryAmount\fP"
.br
.RI "The amount of log entries read in the file, separated by type/severity\&. "
.ti -1c
.RI "std::atomic< std::size_t > \fBm_ullCurrentEntry\fP"
.br
.RI "The number corresponding to the currently-read \fIvalid\fP entry in the log file\&. "
.in -1c
.SH "Detailed Description"
.PP 
ArtyK's Engine's Log Parser; it parses the log files that \fBAELogger\fP writes\&. 

Wrapper around \fBAELogEntry\fP for parsing and \fBAEFileWriter\fP for reading functionality, (ab)using them both\&.
.PP
When opening a file, it reads it and indexes it for log information, and after the parsing/reading the log file to memory can be requested (one entry at a time/the whole thing)\&. Such info would be the amount of entries, amount of entries of each type, etc\&. Also it allows to filter the log by severity and read only important (to the use-case) data\&.
.PP
Hungarian notation is lp\&. (m_lpMyLogParser) 
.PP
Definition at line \fB51\fP of file \fBAELogParser\&.hpp\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "AELogParser::AELogParser (\fBvoid\fP)\fR [inline]\fP"

.PP
Class constructor -- just initialises the object\&. 
.PP
Definition at line \fB58\fP of file \fBAELogParser\&.hpp\fP\&.
.SS "AELogParser::AELogParser (\fBconst\fP std::string_view fname)\fR [inline]\fP, \fR [explicit]\fP"

.PP
Class constructor -- opens the file and start the indexing process\&. 
.PP
\fBParameters\fP
.RS 4
\fIfname\fP The name of the file to open
.RE
.PP

.PP
Definition at line \fB66\fP of file \fBAELogParser\&.hpp\fP\&.
.SS "AELogParser::~AELogParser (\fBvoid\fP)\fR [inline]\fP"

.PP
Class destructor -- closes the log file\&. 
.PP
Definition at line \fB75\fP of file \fBAELogParser\&.hpp\fP\&.
.SH "Member Function Documentation"
.PP 
.SS "\fBullint\fP AELogParser::amountInvalidEntries (\fBvoid\fP) const\fR [inline]\fP, \fR [noexcept]\fP"

.PP
Get the amount of invalid entries in the log\&. Invalid entries are of type AELOG_TYPE_INVALID
.PP
\fBReturns\fP
.RS 4
ullint amount of invalid entries
.RE
.PP

.PP
Definition at line \fB286\fP of file \fBAELogParser\&.hpp\fP\&.
.SS "\fBullint\fP AELogParser::amountTypeEntries (\fBconst\fP \fBcint\fP severity) const\fR [inline]\fP, \fR [noexcept]\fP"

.PP
Get the amount of entries of a certain type/severity\&. 
.PP
\fBParameters\fP
.RS 4
\fIseverity\fP The severity/type of the log to find
.RE
.PP
\fBReturns\fP
.RS 4
ULLINT_MAX if the severity is outside of the AELOG_TYPE_* range; ullint amount of entries
.RE
.PP

.PP
Definition at line \fB295\fP of file \fBAELogParser\&.hpp\fP\&.
.SS "\fBullint\fP AELogParser::amountValidEntries (\fBconst\fP \fBcint\fP severity = \fR\fBAELOG_TYPE_DEBUG\fP\fP) const\fR [inline]\fP, \fR [noexcept]\fP"

.PP
Get the amount of valid entries in the log (with optional lowest severity setting)\&. Valid entries are entries that are not AELOG_TYPE_INVALID
.PP
\fBParameters\fP
.RS 4
\fIseverity\fP The lowest severity of the log to find
.RE
.PP
\fBReturns\fP
.RS 4
ULLINT_MAX if the severity is outside of the AELOG_TYPE_* range; ullint amount of entries
.RE
.PP

.PP
Definition at line \fB271\fP of file \fBAELogParser\&.hpp\fP\&.
.SS "\fBcint\fP AELogParser::closeLog (\fBvoid\fP)\fR [inline]\fP"

.PP
Closes the log file and clears the memory\&. 
.PP
\fBReturns\fP
.RS 4
return value of the AEFileReader::closefile() (AEFR_ERR_NOERROR if file was closed successfully; AEFR_ERR_FILE_NOT_OPEN if file isn't open)
.RE
.PP

.PP
Definition at line \fB90\fP of file \fBAELogParser\&.hpp\fP\&.
.SS "\fBllint\fP AELogParser::currentEntryCursor (\fBvoid\fP) const\fR [inline]\fP, \fR [noexcept]\fP"

.PP
Get the file cursors of the current valid entry This entry is the one that was read by a previous call to \fBAELogParser::nextEntry()\fP or AELogParser::getNextEntryIndex() 
.PP
\fBReturns\fP
.RS 4
The file cursors of the current valid entry (in the currently-opened log file); AEFR_ERR_FILE_NOT_OPEN if the file isn't open
.RE
.PP

.PP
Definition at line \fB212\fP of file \fBAELogParser\&.hpp\fP\&.
.SS "\fBconstexpr\fP bool AELogParser::errorFromAELEI (\fBconst\fP \fBAELogEntryInfo\fP & leInfo) const\fR [inline]\fP, \fR [constexpr]\fP, \fR [private]\fP, \fR [noexcept]\fP"

.PP
Determines the error codes from the invalid values in the passed \fBAELogEntryInfo\fP instance\&. 
.PP
\fBParameters\fP
.RS 4
\fIleInfo\fP The passed \fBAELogEntryInfo\fP instance to check
.RE
.PP
\fBReturns\fP
.RS 4
AELP_ERR_NOERROR if everything is okay; AEFR_ERR_FILE_NOT_OPEN if it's fully invalid; AEFR_ERR_READ_EOF on invalid cursor; AELP_ERR_INVALID_MODULE_NAME on invalid module name; AELP_ERR_INVALID_SEVERITY on invalid type
.RE
.PP

.PP
Definition at line \fB382\fP of file \fBAELogParser\&.hpp\fP\&.
.SS "\fBAELogEntryInfo\fP AELogParser::findNextEntry (\fBconst\fP \fBcint\fP severity, \fBconst\fP std::string_view mname, \fBconst\fP bool strictSeverity)\fR [private]\fP"

.PP
Finds the \fBAELogEntryInfo\fP corresponding to the next log entry with the specified severity and module name\&. 
.PP
\fBParameters\fP
.RS 4
\fIseverity\fP The severity of the log entry to look for
.br
\fImname\fP The module name of the log entry to search for
.br
\fIstrictSeverity\fP The flag to indicate whether the search for severity should be strict (exact)
.RE
.PP
\fBReturns\fP
.RS 4
The \fBAELogEntryInfo\fP instance that corresponds to that log entry
.RE
.PP

.PP
Definition at line \fB119\fP of file \fBAELogParser\&.cpp\fP\&.
.SS "std::size_t AELogParser::getCurrentEntryIndex (\fBvoid\fP) const\fR [inline]\fP, \fR [noexcept]\fP"

.PP
Return the order number (index) of the current log entry (that was just read) 
.PP
\fBReturns\fP
.RS 4
The index of the current entry as std::size_t
.RE
.PP

.PP
Definition at line \fB221\fP of file \fBAELogParser\&.hpp\fP\&.
.SS "std::string AELogParser::getFileName (\fBvoid\fP) const\fR [inline]\fP"

.PP
Returns the name of the opened file, devoid of the path\&. 
.PP
\fBSee also\fP
.RS 4
\fBAEFileReader::getFileName()\fP
.RE
.PP
\fBReturns\fP
.RS 4
std::string of the opened file name; emtpy string otherwise
.RE
.PP

.PP
Definition at line \fB343\fP of file \fBAELogParser\&.hpp\fP\&.
.SS "\fBAEFileReader\fP & AELogParser::getFileReader (\fBvoid\fP)\fR [inline]\fP, \fR [noexcept]\fP"

.PP
Return the reference to the \fBAEFileReader\fP object of this instance of \fBAELogParser\fP\&. 
.PP
\fBWarning\fP
.RS 4
Be carefull with it
.RE
.PP
\fBReturns\fP
.RS 4
the reference to the \fBAEFileReader\fP object
.RE
.PP

.PP
Definition at line \fB361\fP of file \fBAELogParser\&.hpp\fP\&.
.SS "std::string AELogParser::getFullFileName (\fBvoid\fP) const\fR [inline]\fP, \fR [noexcept]\fP"

.PP
Returns the full name of currently open file, including the relative path, if such was provided\&. 
.PP
\fBSee also\fP
.RS 4
\fBAEFileReader::getFullFileName()\fP
.RE
.PP
\fBReturns\fP
.RS 4
std::string of the opened file (including relative path if was given); empty string otherwise
.RE
.PP

.PP
Definition at line \fB325\fP of file \fBAELogParser\&.hpp\fP\&.
.SS "std::string AELogParser::getFullPath (\fBvoid\fP) const\fR [inline]\fP"

.PP
Returns the full, absolute path of the opened file\&. 
.PP
\fBSee also\fP
.RS 4
\fBAEFileReader::getFullPath()\fP
.RE
.PP
\fBReturns\fP
.RS 4
std::string of the absolute path of the opened file; empty string otherwise
.RE
.PP

.PP
Definition at line \fB352\fP of file \fBAELogParser\&.hpp\fP\&.
.SS "std::vector< \fBllint\fP > AELogParser::getInvalidEntryCursorAll (\fBvoid\fP) const\fR [inline]\fP, \fR [noexcept]\fP"

.PP
Get the list of file cursors of the invalid entries\&. In the return vector, llint is the index of the cursor in the file 
.PP
\fBNote\fP
.RS 4
If the file is not open, the returned vector is empty
.RE
.PP
\fBReturns\fP
.RS 4
(by value) The vector of llint's, having the cursor indices for each invalid entry
.RE
.PP

.PP
Definition at line \fB252\fP of file \fBAELogParser\&.hpp\fP\&.
.SS "\fBstatic\fP \fBullint\fP \fB__AEModuleBase\fP< \fBAELogParser\fP  >::getModuleAmount (\fBvoid\fP)\fR [inline]\fP, \fR [static]\fP, \fR [noexcept]\fP, \fR [inherited]\fP"

.PP
Returns the amount of instances of the module currently existing\&. 
.PP
\fBReturns\fP
.RS 4
Unsigned long long of the module amount
.RE
.PP

.PP
Definition at line \fB85\fP of file \fBAEModuleBase\&.hpp\fP\&.
.SS "\fBstatic\fP \fBconstexpr\fP std::string_view \fB__AEModuleBase\fP< \fBAELogParser\fP  >::getModuleName (\fBvoid\fP)\fR [static]\fP, \fR [constexpr]\fP, \fR [noexcept]\fP, \fR [inherited]\fP"

.PP
Returns the name of the registered module\&. 
.PP
\fBReturns\fP
.RS 4

.RE
.PP

.SS "std::string AELogParser::getRelativePath (\fBvoid\fP) const\fR [inline]\fP"

.PP
Returns the relative path of the opened file\&. 
.PP
\fBSee also\fP
.RS 4
\fBAEFileReader::getRelativePath()\fP
.RE
.PP
\fBReturns\fP
.RS 4
std::string of the relative file path of opened file; empty string otherwise
.RE
.PP

.PP
Definition at line \fB334\fP of file \fBAELogParser\&.hpp\fP\&.
.SS "std::vector< \fBAELogEntryInfo\fP > AELogParser::getValidEntryCursorAll (\fBvoid\fP) const\fR [inline]\fP, \fR [noexcept]\fP"

.PP
Get the list of file cursors of the valid entries, separated by type\&. 
.PP
\fBNote\fP
.RS 4
If the file is not open, the returned vector is empty
.RE
.PP
\fBReturns\fP
.RS 4
(by value) The vector of \fBAELogEntryInfo\fP, each having the (cursor) index, index of the module name, and type of each valid entry
.RE
.PP

.PP
Definition at line \fB242\fP of file \fBAELogParser\&.hpp\fP\&.
.SS "bool AELogParser::isClosed (\fBvoid\fP) const\fR [inline]\fP, \fR [noexcept]\fP"

.PP
Checks if the file is closed by the \fBAELogParser\fP\&. 
.PP
\fBSee also\fP
.RS 4
\fBAEFileReader::isClosed()\fP
.RE
.PP
\fBReturns\fP
.RS 4
true is file is closed (no file opened), false otherwise
.RE
.PP

.PP
Definition at line \fB316\fP of file \fBAELogParser\&.hpp\fP\&.
.SS "bool AELogParser::isOpen (\fBvoid\fP) const\fR [inline]\fP, \fR [noexcept]\fP"

.PP
Checks if the file is opened by the \fBAELogParser\fP\&. 
.PP
\fBSee also\fP
.RS 4
\fBAEFileReader::isOpen()\fP
.RE
.PP
\fBReturns\fP
.RS 4
true if file is opened, false otherwise
.RE
.PP

.PP
Definition at line \fB307\fP of file \fBAELogParser\&.hpp\fP\&.
.SS "\fBcint\fP AELogParser::logToQueue (\fBAELogEntry\fP *& begin, \fBconst\fP \fBcint\fP severity = \fR\fBAELOG_TYPE_DEBUG\fP\fP)"

.PP
Same as the \fBAELogParser::nextEntry()\fP but on massive scale -- scans the whole log file and parses it to the freshly-allocated queue\&. 
.PP
\fBWarning\fP
.RS 4
If this queue isn't deallocated (deleted) before dropping the queue pointer, this \fBWILL\fP lead to memory leaks!
.RE
.PP
\fBParameters\fP
.RS 4
\fIbegin\fP The pointer to which the queue will be allocated
.br
\fIseverity\fP The lowest severity of the log to find
.RE
.PP
\fBReturns\fP
.RS 4
AELP_ERR_NOERROR (0) on success, or AEFR_ERR_* (-1 to -8) or AELE_ERR_* (-11 to -15) flags on error
.RE
.PP

.PP
Definition at line \fB94\fP of file \fBAELogParser\&.cpp\fP\&.
.SS "\fBcint\fP AELogParser::nextEntry (\fBAELogEntry\fP & entry, \fBconst\fP \fBcint\fP severity = \fR\fBAELOG_TYPE_DEBUG\fP\fP, \fBconst\fP std::string_view mname = \fR''\fP, \fBconst\fP bool strictSeverity = \fR\fBfalse\fP\fP)"

.PP
Read the next \fIvalid\fP entry in the log file of the given severity and module name filter, and parse it to the given \fBAELogEntry\fP object\&. 
.PP
\fBNote\fP
.RS 4
If the strictSeverity is false, then the severity value just changes the lowest limit of the log severity\&. Otherwise it sets the exact severity to look for 
.PP
The module name filter is applied after the severity filter\&. 
.PP
AELOG_TYPE_INVALID works the same as AELOG_TYPE_DEBUG\&. This function parses only \fIvalid\fP entries\&.
.RE
.PP
\fBParameters\fP
.RS 4
\fIentry\fP The log entry object to parse things into
.br
\fIseverity\fP The severity of the log entry to look for
.br
\fImname\fP The module name of the log entry to search for
.br
\fIstrictSeverity\fP The flag to indicate whether the search for severity should be strict (exact)
.RE
.PP
\fBReturns\fP
.RS 4
AELP_ERR_NOERROR (0) on success, or AEFR_ERR_* (-1 to -8) or AELE_ERR_* (-11 to -15) flags on error; error codes from \fBAELogParser::errorFromAELEI()\fP
.RE
.PP
\fBSee also\fP
.RS 4
\fBAELogParser::errorFromAELEI()\fP 
.RE
.PP

.PP
Definition at line \fB72\fP of file \fBAELogParser\&.cpp\fP\&.
.SS "\fBllint\fP AELogParser::nextEntryCursor (\fBconst\fP \fBcint\fP severity = \fR\fBAELOG_TYPE_DEBUG\fP\fP, \fBconst\fP std::string_view mname = \fR''\fP, \fBconst\fP bool strictSeverity = \fR\fBfalse\fP\fP)\fR [inline]\fP"

.PP
Read the next indexed \fIvalid\fP log entry in the file of the given severity and module name filter, and return it's file cursors in the file\&. 
.PP
\fBNote\fP
.RS 4
The severity value just changes the lowest limit of the log severity (lowest by default is debug)\&. If a higher severity is encountered, it's read as well\&. 
.PP
AELOG_TYPE_INVALID works the same as AELOG_TYPE_DEBUG\&. This function parses only \fIvalid\fP entries\&.
.RE
.PP
\fBParameters\fP
.RS 4
\fIseverity\fP The lowest severity of the log to find
.br
\fImname\fP The module name of the log entry to search for
.br
\fIstrictSeverity\fP The flag to indicate whether the search for severity should be strict (exact)
.RE
.PP
\fBReturns\fP
.RS 4
The file cursors of the next valid entry (in the currently-opened log file); error codes from \fBAELogParser::errorFromAELEI()\fP
.RE
.PP
\fBSee also\fP
.RS 4
\fBAELogParser::errorFromAELEI()\fP 
.RE
.PP

.PP
Definition at line \fB165\fP of file \fBAELogParser\&.hpp\fP\&.
.SS "\fBllint\fP AELogParser::nextEntryCursorName (\fBconst\fP std::string_view mname)\fR [inline]\fP"

.PP
Read the next indexed \fIvalid\fP log entry in the file of the given module name filter, and return it's file cursors in the file\&. 
.PP
\fBSee also\fP
.RS 4
\fBAELogParser::nextEntryCursor()\fP
.RE
.PP
\fBParameters\fP
.RS 4
\fImname\fP The module name of the log entry to search for
.RE
.PP
\fBReturns\fP
.RS 4
The file cursors of the next valid entry (in the currently-opened log file); error codes from \fBAELogParser::errorFromAELEI()\fP
.RE
.PP
\fBSee also\fP
.RS 4
\fBAELogParser::errorFromAELEI()\fP 
.RE
.PP

.PP
Definition at line \fB183\fP of file \fBAELogParser\&.hpp\fP\&.
.SS "\fBllint\fP AELogParser::nextEntryCursorType (\fBconst\fP \fBcint\fP severity, \fBconst\fP bool strictSeverity = \fR\fBfalse\fP\fP)\fR [inline]\fP"

.PP
Read the next indexed \fIvalid\fP log entry in the file of the given severity filter and return it's file cursors in the file\&. 
.PP
\fBNote\fP
.RS 4
AELOG_TYPE_INVALID works the same as AELOG_TYPE_DEBUG\&. This function parses only \fIvalid\fP entries\&. 
.RE
.PP
\fBSee also\fP
.RS 4
\fBAELogParser::nextEntryCursor()\fP
.RE
.PP
\fBParameters\fP
.RS 4
\fIseverity\fP The lowest severity of the log to find
.br
\fIstrictSeverity\fP The flag to indicate whether the search for severity should be strict (exact)
.RE
.PP
\fBReturns\fP
.RS 4
The file cursors of the next valid entry (in the currently-opened log file); error codes from \fBAELogParser::errorFromAELEI()\fP
.RE
.PP
\fBSee also\fP
.RS 4
\fBAELogParser::errorFromAELEI()\fP 
.RE
.PP

.PP
Definition at line \fB194\fP of file \fBAELogParser\&.hpp\fP\&.
.SS "\fBllint\fP AELogParser::nextEntryCursorTypeStrict (\fBconst\fP \fBcint\fP severity)\fR [inline]\fP"

.PP
Read the next indexed \fIvalid\fP log entry in the file of the given severity filter and return it's file cursors in the file\&. 
.PP
\fBNote\fP
.RS 4
This severity search is strict (calls \fBAELogParser::nextEntryCursor()\fP and sets strictSeverity to true) 
.PP
AELOG_TYPE_INVALID works the same as AELOG_TYPE_DEBUG\&. This function parses only \fIvalid\fP entries\&. 
.RE
.PP
\fBSee also\fP
.RS 4
\fBAELogParser::nextEntryCursor()\fP
.RE
.PP
\fBParameters\fP
.RS 4
\fIseverity\fP The lowest severity of the log to find
.RE
.PP
\fBReturns\fP
.RS 4
The file cursors of the next valid entry (in the currently-opened log file); error codes from \fBAELogParser::errorFromAELEI()\fP
.RE
.PP
\fBSee also\fP
.RS 4
\fBAELogParser::errorFromAELEI()\fP 
.RE
.PP

.PP
Definition at line \fB205\fP of file \fBAELogParser\&.hpp\fP\&.
.SS "\fBcint\fP AELogParser::nextEntryName (\fBAELogEntry\fP & entry, \fBconst\fP std::string_view mname)\fR [inline]\fP"

.PP
Read the next \fIvalid\fP entry in the log file of the given module name, and parse it into the given \fBAELogEntry\fP object\&. 
.PP
\fBSee also\fP
.RS 4
\fBAELogParser::nextEntry()\fP
.RE
.PP
\fBParameters\fP
.RS 4
\fIentry\fP The log entry object to parse things into
.br
\fImname\fP The module name of the log entry to search for
.RE
.PP
\fBReturns\fP
.RS 4
AELP_ERR_NOERROR (0) on success, or AEFR_ERR_* (-1 to -8) or AELE_ERR_* (-11 to -15) flags on error; error codes from \fBAELogParser::errorFromAELEI()\fP
.RE
.PP
\fBSee also\fP
.RS 4
\fBAELogParser::errorFromAELEI()\fP 
.RE
.PP

.PP
Definition at line \fB127\fP of file \fBAELogParser\&.hpp\fP\&.
.SS "\fBcint\fP AELogParser::nextEntryType (\fBAELogEntry\fP & entry, \fBconst\fP \fBcint\fP severity, \fBconst\fP bool strictSeverity = \fR\fBfalse\fP\fP)\fR [inline]\fP"

.PP
Read the next \fIvalid\fP entry in the log file of the given severity, and parse it to the given \fBAELogEntry\fP object\&. 
.PP
\fBSee also\fP
.RS 4
AELogEntry::nextEntry()
.RE
.PP
\fBParameters\fP
.RS 4
\fIentry\fP The log entry object to parse things into
.br
\fIseverity\fP The lowest limit of severity of the log entry to look for
.br
\fIstrictSeverity\fP The flag to indicate whether the search for severity should be strict (exact)
.RE
.PP
\fBReturns\fP
.RS 4
AELP_ERR_NOERROR (0) on success, or AEFR_ERR_* (-1 to -8) or AELE_ERR_* (-11 to -15) flags on error; error codes from \fBAELogParser::errorFromAELEI()\fP
.RE
.PP
\fBSee also\fP
.RS 4
\fBAELogParser::errorFromAELEI()\fP 
.RE
.PP

.PP
Definition at line \fB138\fP of file \fBAELogParser\&.hpp\fP\&.
.SS "\fBcint\fP AELogParser::nextEntryTypeStrict (\fBAELogEntry\fP & entry, \fBconst\fP \fBcint\fP severity)\fR [inline]\fP"

.PP
Read the next \fIvalid\fP entry in the log file of the given severity, and parse it to the given \fBAELogEntry\fP object\&. 
.PP
\fBNote\fP
.RS 4
This severity search is strict (calls \fBAELogParser::nextEntry()\fP and sets strictSeverity to true) 
.RE
.PP
\fBSee also\fP
.RS 4
AELogEntry::nextEntry()
.RE
.PP
\fBParameters\fP
.RS 4
\fIentry\fP The log entry object to parse things into
.br
\fIseverity\fP The severity of the log entry to look for
.RE
.PP
\fBReturns\fP
.RS 4
AELP_ERR_NOERROR (0) on success, or AEFR_ERR_* (-1 to -8) or AELE_ERR_* (-11 to -15) flags on error; error codes from \fBAELogParser::errorFromAELEI()\fP
.RE
.PP
\fBSee also\fP
.RS 4
\fBAELogParser::errorFromAELEI()\fP 
.RE
.PP

.PP
Definition at line \fB151\fP of file \fBAELogParser\&.hpp\fP\&.
.SS "\fBcint\fP AELogParser::openLog (\fBconst\fP std::string_view fname)"

.PP
Opens the log file, reading and parsing every single entry, classifying it by type\&. 
.PP
\fBParameters\fP
.RS 4
\fIfname\fP The name of the file to open
.RE
.PP
\fBReturns\fP
.RS 4
AELP_ERR_NOERROR (0) on success, or AEFR_ERR_* (-1 to -8) or AELE_ERR_* (-11 to -15) flags on error
.RE
.PP

.PP
Definition at line \fB11\fP of file \fBAELogParser\&.cpp\fP\&.
.SS "AELogParser::REGISTER_MODULE (\fBAELogParser\fP)\fR [private]\fP"

.SS "\fBcint\fP AELogParser::setNextEntryIndex (\fBconst\fP std::size_t entryIndex)\fR [inline]\fP, \fR [noexcept]\fP"

.PP
Set the order number (index) of the next log entry to be parsed\&. 
.PP
\fBParameters\fP
.RS 4
\fIentryIndex\fP The order number of the next entry
.RE
.PP
\fBReturns\fP
.RS 4
AELP_ERR_NOERROR on success; AEFR_ERR_READ_EOF if the value was larger than the (amount of valid parsed entries - 1); AEFR_ERR_FILE_NOT_OPEN if file wasn't open
.RE
.PP

.PP
Definition at line \fB228\fP of file \fBAELogParser\&.hpp\fP\&.
.SH "Member Data Documentation"
.PP 
.SS "std::array<\fBullint\fP, 9> AELogParser::m_arrEntryAmount\fR [private]\fP"

.PP
The amount of log entries read in the file, separated by type/severity\&. 
.PP
Definition at line \fB412\fP of file \fBAELogParser\&.hpp\fP\&.
.SS "\fBAEFileReader\fP AELogParser::m_frLogReader\fR [private]\fP"

.PP
The file reader of the opened log file\&. 
.PP
Definition at line \fB402\fP of file \fBAELogParser\&.hpp\fP\&.
.SS "std::unordered_map<std::string, short> AELogParser::m_mapModuleNames\fR [private]\fP"

.PP
The map of the all module names parsed in the log file\&. 
.PP
Definition at line \fB410\fP of file \fBAELogParser\&.hpp\fP\&.
.SS "std::atomic<std::size_t> AELogParser::m_ullCurrentEntry\fR [private]\fP"

.PP
The number corresponding to the currently-read \fIvalid\fP entry in the log file\&. The maximum value corresponds to the size of m_vecEntryIndices 
.PP
Definition at line \fB415\fP of file \fBAELogParser\&.hpp\fP\&.
.SS "std::atomic<\fBullint\fP> \fB__AEModuleBase\fP< \fBAELogParser\fP  >::m_ullModulesAlive\fR [inline]\fP, \fR [static]\fP, \fR [protected]\fP, \fR [inherited]\fP"

.PP
Amount of alive module instances\&. 
.PP
Definition at line \fB100\fP of file \fBAEModuleBase\&.hpp\fP\&.
.SS "std::vector<\fBAELogEntryInfo\fP> AELogParser::m_vecEntryIndices\fR [private]\fP"

.PP
The list of all indexed \fIvalid\fP entries in the log file\&. Each item contains their corresponding cursor position in the file and their type/severity\&. 
.PP
Definition at line \fB405\fP of file \fBAELogParser\&.hpp\fP\&.
.SS "std::vector<\fBllint\fP> AELogParser::m_vecInvalidEntryIndices\fR [private]\fP"

.PP
The list of all indexed \fIinvalid\fP entries in the log file Each item contains their corresponding cursor position in the file\&. 
.PP
Definition at line \fB408\fP of file \fBAELogParser\&.hpp\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for ArtyK's Console Engine from the source code\&.

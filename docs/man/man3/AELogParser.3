.TH "AELogParser" 3 "Thu Feb 8 2024 13:09:56" "Version v0.0.8.5a" "ArtyK's Console Engine" \" -*- nroff -*-
.ad l
.nh
.SH NAME
AELogParser \- ArtyK's Engine's Log Parser; it parses the log files that \fBAELogger\fP writes\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fR#include <AELogParser\&.hpp>\fP
.PP
Inherits \fB__AEModuleBase< AELogParser >\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBAELogParser\fP (\fBvoid\fP)"
.br
.RI "Class constructor -- just initialises the object\&. "
.ti -1c
.RI "\fBAELogParser\fP (\fBconst\fP std::string_view \fBfname\fP)"
.br
.RI "Class constructor -- opens the file and start the indexing process\&. "
.ti -1c
.RI "\fB~AELogParser\fP (\fBvoid\fP)"
.br
.RI "Class destructor -- closes the log file\&. "
.ti -1c
.RI "\fBcint\fP \fBopenLog\fP (\fBconst\fP std::string_view \fBfname\fP)"
.br
.RI "Opens the log file, reading and parsing every single entry, classifying it by type\&. "
.ti -1c
.RI "\fBcint\fP \fBcloseLog\fP (\fBvoid\fP)"
.br
.RI "Closes the log file and clears the memory\&. "
.ti -1c
.RI "\fBcint\fP \fBnextEntry\fP (\fBAELogEntry\fP &\fBentry\fP, \fBconst\fP \fBcint\fP \fBseverity\fP=\fBAELOG_TYPE_DEBUG\fP)"
.br
.RI "Read the next \fIvalid\fP entry in the log file of the given severity filter, and parse it to the given \fBAELogEntry\fP object\&. "
.ti -1c
.RI "\fBcint\fP \fBnextEntryDebug\fP (\fBAELogEntry\fP &\fBentry\fP)"
.br
.RI "Read next \fIvalud\fP entry in the log file of 'debug' type, and parse it to the given \fBAELogEntry\fP object\&. "
.ti -1c
.RI "\fBcint\fP \fBnextEntryInfo\fP (\fBAELogEntry\fP &\fBentry\fP)"
.br
.RI "Read next \fIvalud\fP entry in the log file of 'info' type, and parse it to the given \fBAELogEntry\fP object\&. "
.ti -1c
.RI "\fBcint\fP \fBnextEntryWarn\fP (\fBAELogEntry\fP &\fBentry\fP)"
.br
.RI "Read next \fIvalud\fP entry in the log file of 'warning' type, and parse it to the given \fBAELogEntry\fP object\&. "
.ti -1c
.RI "\fBcint\fP \fBnextEntrySevereWarn\fP (\fBAELogEntry\fP &\fBentry\fP)"
.br
.RI "Read next \fIvalud\fP entry in the log file of 'severe warning' type, and parse it to the given \fBAELogEntry\fP object\&. "
.ti -1c
.RI "\fBcint\fP \fBnextEntryOK\fP (\fBAELogEntry\fP &\fBentry\fP)"
.br
.RI "Read next \fIvalud\fP entry in the log file of 'OK' type, and parse it to the given \fBAELogEntry\fP object\&. "
.ti -1c
.RI "\fBcint\fP \fBnextEntrySuccess\fP (\fBAELogEntry\fP &\fBentry\fP)"
.br
.RI "Read next \fIvalud\fP entry in the log file of 'success' type, and parse it to the given \fBAELogEntry\fP object\&. "
.ti -1c
.RI "\fBcint\fP \fBnextEntryError\fP (\fBAELogEntry\fP &\fBentry\fP)"
.br
.RI "Read next \fIvalud\fP entry in the log file of 'error' type, and parse it to the given \fBAELogEntry\fP object\&. "
.ti -1c
.RI "\fBcint\fP \fBnextEntryFatalError\fP (\fBAELogEntry\fP &\fBentry\fP)"
.br
.RI "Read next \fIvalud\fP entry in the log file of 'fatal error' type, and parse it to the given \fBAELogEntry\fP object\&. "
.ti -1c
.RI "\fBllint\fP \fBnextEntryCursor\fP (\fBconst\fP \fBcint\fP \fBseverity\fP=\fBAELOG_TYPE_DEBUG\fP)"
.br
.RI "Read the next indexed \fIvalid\fP log entry in the file of the given severity filter and return it's file cursors in the file\&. "
.ti -1c
.RI "\fBllint\fP \fBnextEntryCursorDebug\fP (\fBvoid\fP)"
.br
.RI "Read the next indexed valid log entry in the opened file of type 'debug', and return the file cursor to it\&. "
.ti -1c
.RI "\fBllint\fP \fBnextEntryCursorInfo\fP (\fBvoid\fP)"
.br
.RI "Read the next indexed valid log entry in the opened file of type 'info', and return the file cursor to it\&. "
.ti -1c
.RI "\fBllint\fP \fBnextEntryCursorWarn\fP (\fBvoid\fP)"
.br
.RI "Read the next indexed valid log entry in the opened file of type 'warning', and return the file cursor to it\&. "
.ti -1c
.RI "\fBllint\fP \fBnextEntryCursorSevereWarn\fP (\fBvoid\fP)"
.br
.RI "Read the next indexed valid log entry in the opened file of type 'severe warning', and return the file cursor to it\&. "
.ti -1c
.RI "\fBllint\fP \fBnextEntryCursorOK\fP (\fBvoid\fP)"
.br
.RI "Read the next indexed valid log entry in the opened file of type 'OK', and return the file cursor to it\&. "
.ti -1c
.RI "\fBllint\fP \fBnextEntryCursorSuccess\fP (\fBvoid\fP)"
.br
.RI "Read the next indexed valid log entry in the opened file of type 'success', and return the file cursor to it\&. "
.ti -1c
.RI "\fBllint\fP \fBnextEntryCursorError\fP (\fBvoid\fP)"
.br
.RI "Read the next indexed valid log entry in the opened file of type 'rror', and return the file cursor to it\&. "
.ti -1c
.RI "\fBllint\fP \fBnextEntryCursorFatalError\fP (\fBvoid\fP)"
.br
.RI "Read the next indexed valid log entry in the opened file of type 'fatal error', and return the file cursor to it\&. "
.ti -1c
.RI "\fBllint\fP \fBcurrentEntryCursor\fP (\fBvoid\fP) \fBconst\fP"
.br
.RI "Get the file cursors of the current valid entry This entry is the one that was read by a previous call to \fBAELogParser::nextEntry()\fP or AELogParser::getNextEntryIndex() "
.ti -1c
.RI "std::size_t \fBgetCurrentEntryIndex\fP (\fBvoid\fP) \fBconst\fP"
.br
.ti -1c
.RI "\fBcint\fP \fBsetCurrentEntryIndex\fP (\fBconst\fP std::size_t \fBentryIndex\fP)"
.br
.ti -1c
.RI "std::vector< std::pair< \fBllint\fP, \fBcint\fP > > \fBgetValidEntryCursorAll\fP (\fBvoid\fP) \fBconst\fP \fBnoexcept\fP"
.br
.RI "Get the list of file cursors of the valid entries, separated by type\&. "
.ti -1c
.RI "std::vector< \fBllint\fP > \fBgetInvalidEntryCursorAll\fP (\fBvoid\fP) \fBconst\fP \fBnoexcept\fP"
.br
.RI "Get the list of file cursors of the invalid entries\&. "
.ti -1c
.RI "\fBcint\fP \fBlogToQueue\fP (\fBAELogEntry\fP *&\fBbegin\fP, \fBconst\fP \fBcint\fP \fBseverity\fP=\fBAELOG_TYPE_DEBUG\fP)"
.br
.RI "Same as the \fBAELogParser::nextEntry()\fP but on massive scale -- scans the whole log file and parses it to the freshly-allocated queue\&. "
.ti -1c
.RI "\fBullint\fP \fBamountValidEntries\fP (\fBconst\fP \fBcint\fP \fBseverity\fP=\fBAELOG_TYPE_DEBUG\fP) \fBconst\fP \fBnoexcept\fP"
.br
.RI "Get the amount of valid entries in the log (with optional lowest severity setting)\&. "
.ti -1c
.RI "\fBullint\fP \fBamountInvalidEntries\fP (\fBvoid\fP) \fBconst\fP \fBnoexcept\fP"
.br
.RI "Get the amount of invalid entries in the log\&. "
.ti -1c
.RI "\fBullint\fP \fBamountTypeEntries\fP (\fBconst\fP \fBcint\fP \fBseverity\fP) \fBconst\fP \fBnoexcept\fP"
.br
.RI "Get the amount of entries of a certain type/severity\&. "
.ti -1c
.RI "bool \fBisOpen\fP (\fBvoid\fP) \fBconst\fP \fBnoexcept\fP"
.br
.RI "Checks if the file is opened by the \fBAELogParser\fP\&. "
.ti -1c
.RI "bool \fBisClosed\fP (\fBvoid\fP) \fBconst\fP \fBnoexcept\fP"
.br
.RI "Checks if the file is closed by the \fBAELogParser\fP\&. "
.ti -1c
.RI "std::string \fBgetFullFileName\fP (\fBvoid\fP) \fBconst\fP \fBnoexcept\fP"
.br
.RI "Returns the full name of currently open file, including the relative path, if such was provided\&. "
.ti -1c
.RI "std::string \fBgetRelativePath\fP (\fBvoid\fP) \fBconst\fP"
.br
.RI "Returns the relative path of the opened file\&. "
.ti -1c
.RI "std::string \fBgetFileName\fP (\fBvoid\fP) \fBconst\fP"
.br
.RI "Returns the name of the opened file, devoid of the path\&. "
.ti -1c
.RI "std::string \fBgetFullPath\fP (\fBvoid\fP) \fBconst\fP"
.br
.RI "Returns the full, absolute path of the opened file\&. "
.ti -1c
.RI "\fBAEFileReader\fP & \fBgetFileReader\fP (\fBvoid\fP) \fBnoexcept\fP"
.br
.RI "Return the reference to the \fBAEFileReader\fP object of this instance of \fBAELogParser\fP\&. "
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "\fBstatic\fP \fBullint\fP \fBgetModuleAmount\fP (\fBvoid\fP) \fBnoexcept\fP"
.br
.RI "Returns the amount of instances of the module currently existing\&. "
.ti -1c
.RI "\fBstatic\fP \fBconstexpr\fP std::string_view \fBgetModuleName\fP (\fBvoid\fP) \fBnoexcept\fP"
.br
.RI "Returns the name of the registered module\&. "
.in -1c
.SS "Static Protected Attributes"

.in +1c
.ti -1c
.RI "\fBstatic\fP std::atomic< \fBullint\fP > \fBm_ullModulesAlive\fP"
.br
.RI "Amount of alive module instances\&. "
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "\fBAEFileReader\fP \fBm_frLogReader\fP"
.br
.RI "The file reader of the opened log file\&. "
.ti -1c
.RI "std::vector< std::pair< \fBllint\fP, \fBcint\fP > > \fBm_vecEntryIndices\fP"
.br
.RI "The list of all indexed \fIvalid\fP entries in the log file\&. "
.ti -1c
.RI "std::vector< \fBllint\fP > \fBm_vecInvalidEntryIndices\fP"
.br
.RI "The list of all indexed \fIinvalid\fP entries in the log file Each item contains their corresponding cursor position in the file\&. "
.ti -1c
.RI "std::array< \fBullint\fP, 9 > \fBm_arrEntryAmount\fP"
.br
.RI "The amount of log entries read in the file, separated by type/severity\&. "
.ti -1c
.RI "std::atomic< std::size_t > \fBm_ullCurrentEntry\fP"
.br
.RI "The number corresponding to the currently-read \fIvalid\fP entry in the log file\&. "
.in -1c
.SH "Detailed Description"
.PP 
ArtyK's Engine's Log Parser; it parses the log files that \fBAELogger\fP writes\&. 

Wrapper around \fBAELogEntry\fP for parsing and \fBAEFileWriter\fP for reading functionality, (ab)using them both\&.
.PP
When opening a file, it reads it and indexes it for log information, and after the parsing/reading the log file to memory can be requested (one entry at a time/the whole thing)\&. Such info would be the amount of entries, amount of entries of each type, etc\&. Also it allows to filter the log by severity and read only important (to the use-case) data\&.
.PP
Hungarian notation is lp\&. (m_lpMyLogParser) 
.PP
Definition at line \fB38\fP of file \fBAELogParser\&.hpp\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "AELogParser::AELogParser (\fBvoid\fP)\fR [inline]\fP"

.PP
Class constructor -- just initialises the object\&. 
.PP
Definition at line \fB46\fP of file \fBAELogParser\&.hpp\fP\&.
.SS "AELogParser::AELogParser (\fBconst\fP std::string_view fname)\fR [inline]\fP, \fR [explicit]\fP"

.PP
Class constructor -- opens the file and start the indexing process\&. 
.PP
\fBParameters\fP
.RS 4
\fIfname\fP The name of the file to open
.RE
.PP

.PP
Definition at line \fB57\fP of file \fBAELogParser\&.hpp\fP\&.
.SS "AELogParser::~AELogParser (\fBvoid\fP)\fR [inline]\fP"

.PP
Class destructor -- closes the log file\&. 
.PP
Definition at line \fB68\fP of file \fBAELogParser\&.hpp\fP\&.
.SH "Member Function Documentation"
.PP 
.SS "\fBullint\fP AELogParser::amountInvalidEntries (\fBvoid\fP) const\fR [inline]\fP, \fR [noexcept]\fP"

.PP
Get the amount of invalid entries in the log\&. Invalid entries are of type AELOG_TYPE_INVALID
.PP
\fBReturns\fP
.RS 4
ullint amount of invalid entries
.RE
.PP

.PP
Definition at line \fB317\fP of file \fBAELogParser\&.hpp\fP\&.
.SS "\fBullint\fP AELogParser::amountTypeEntries (\fBconst\fP \fBcint\fP severity) const\fR [inline]\fP, \fR [noexcept]\fP"

.PP
Get the amount of entries of a certain type/severity\&. 
.PP
\fBParameters\fP
.RS 4
\fIseverity\fP The severity/type of the log to find
.RE
.PP
\fBReturns\fP
.RS 4
ULLINT_MAX if the severity is outside of the AELOG_TYPE_* range; ullint amount of entries
.RE
.PP

.PP
Definition at line \fB326\fP of file \fBAELogParser\&.hpp\fP\&.
.SS "\fBullint\fP AELogParser::amountValidEntries (\fBconst\fP \fBcint\fP severity = \fR\fBAELOG_TYPE_DEBUG\fP\fP) const\fR [inline]\fP, \fR [noexcept]\fP"

.PP
Get the amount of valid entries in the log (with optional lowest severity setting)\&. Valid entries are entries that are not AELOG_TYPE_INVALID
.PP
\fBParameters\fP
.RS 4
\fIseverity\fP The lowest severity of the log to find
.RE
.PP
\fBReturns\fP
.RS 4
ULLINT_MAX if the severity is outside of the AELOG_TYPE_* range; ullint amount of entries
.RE
.PP

.PP
Definition at line \fB302\fP of file \fBAELogParser\&.hpp\fP\&.
.SS "\fBcint\fP AELogParser::closeLog (\fBvoid\fP)\fR [inline]\fP"

.PP
Closes the log file and clears the memory\&. 
.PP
\fBReturns\fP
.RS 4
return value of the AEFileReader::closefile() (AEFR_ERR_NOERROR if file was closed successfully; AEFR_ERR_FILE_NOT_OPEN if file isn't open)
.RE
.PP

.PP
Definition at line \fB83\fP of file \fBAELogParser\&.hpp\fP\&.
.SS "\fBllint\fP AELogParser::currentEntryCursor (\fBvoid\fP) const\fR [inline]\fP"

.PP
Get the file cursors of the current valid entry This entry is the one that was read by a previous call to \fBAELogParser::nextEntry()\fP or AELogParser::getNextEntryIndex() 
.PP
\fBReturns\fP
.RS 4
The file cursors of the current valid entry (in the currently-opened log file); AEFR_ERR_FILE_NOT_OPEN if the file isn't open
.RE
.PP

.PP
Definition at line \fB250\fP of file \fBAELogParser\&.hpp\fP\&.
.SS "std::size_t AELogParser::getCurrentEntryIndex (\fBvoid\fP) const\fR [inline]\fP"

.PP
Definition at line \fB255\fP of file \fBAELogParser\&.hpp\fP\&.
.SS "std::string AELogParser::getFileName (\fBvoid\fP) const\fR [inline]\fP"

.PP
Returns the name of the opened file, devoid of the path\&. 
.PP
\fBSee also\fP
.RS 4
\fBAEFileReader::getFileName()\fP
.RE
.PP
\fBReturns\fP
.RS 4
std::string of the opened file name; emtpy string otherwise
.RE
.PP

.PP
Definition at line \fB374\fP of file \fBAELogParser\&.hpp\fP\&.
.SS "\fBAEFileReader\fP & AELogParser::getFileReader (\fBvoid\fP)\fR [inline]\fP, \fR [noexcept]\fP"

.PP
Return the reference to the \fBAEFileReader\fP object of this instance of \fBAELogParser\fP\&. 
.PP
\fBWarning\fP
.RS 4
Be carefull with it
.RE
.PP
\fBReturns\fP
.RS 4
the reference to the \fBAEFileReader\fP object
.RE
.PP

.PP
Definition at line \fB392\fP of file \fBAELogParser\&.hpp\fP\&.
.SS "std::string AELogParser::getFullFileName (\fBvoid\fP) const\fR [inline]\fP, \fR [noexcept]\fP"

.PP
Returns the full name of currently open file, including the relative path, if such was provided\&. 
.PP
\fBSee also\fP
.RS 4
\fBAEFileReader::getFullFileName()\fP
.RE
.PP
\fBReturns\fP
.RS 4
std::string of the opened file (including relative path if was given); empty string otherwise
.RE
.PP

.PP
Definition at line \fB356\fP of file \fBAELogParser\&.hpp\fP\&.
.SS "std::string AELogParser::getFullPath (\fBvoid\fP) const\fR [inline]\fP"

.PP
Returns the full, absolute path of the opened file\&. 
.PP
\fBSee also\fP
.RS 4
\fBAEFileReader::getFullPath()\fP
.RE
.PP
\fBReturns\fP
.RS 4
std::string of the absolute path of the opened file; empty string otherwise
.RE
.PP

.PP
Definition at line \fB383\fP of file \fBAELogParser\&.hpp\fP\&.
.SS "std::vector< \fBllint\fP > AELogParser::getInvalidEntryCursorAll (\fBvoid\fP) const\fR [inline]\fP, \fR [noexcept]\fP"

.PP
Get the list of file cursors of the invalid entries\&. In the return vector, llint is the index of the cursor in the file 
.PP
\fBNote\fP
.RS 4
If the file is not open, the returned vector is empty
.RE
.PP
\fBReturns\fP
.RS 4
(by value) The vector of llint's, having the cursor indices for each invalid entry
.RE
.PP

.PP
Definition at line \fB283\fP of file \fBAELogParser\&.hpp\fP\&.
.SS "\fBstatic\fP \fBullint\fP \fB__AEModuleBase\fP< \fBAELogParser\fP  >::getModuleAmount (\fBvoid\fP)\fR [inline]\fP, \fR [static]\fP, \fR [noexcept]\fP, \fR [inherited]\fP"

.PP
Returns the amount of instances of the module currently existing\&. 
.PP
\fBReturns\fP
.RS 4
Unsigned long long of the module amount
.RE
.PP

.PP
Definition at line \fB85\fP of file \fBAEModuleBase\&.hpp\fP\&.
.SS "\fBstatic\fP \fBconstexpr\fP std::string_view \fB__AEModuleBase\fP< \fBAELogParser\fP  >::getModuleName (\fBvoid\fP)\fR [static]\fP, \fR [constexpr]\fP, \fR [noexcept]\fP, \fR [inherited]\fP"

.PP
Returns the name of the registered module\&. 
.PP
\fBReturns\fP
.RS 4

.RE
.PP

.SS "std::string AELogParser::getRelativePath (\fBvoid\fP) const\fR [inline]\fP"

.PP
Returns the relative path of the opened file\&. 
.PP
\fBSee also\fP
.RS 4
\fBAEFileReader::getRelativePath()\fP
.RE
.PP
\fBReturns\fP
.RS 4
std::string of the relative file path of opened file; empty string otherwise
.RE
.PP

.PP
Definition at line \fB365\fP of file \fBAELogParser\&.hpp\fP\&.
.SS "std::vector< std::pair< \fBllint\fP, \fBcint\fP > > AELogParser::getValidEntryCursorAll (\fBvoid\fP) const\fR [inline]\fP, \fR [noexcept]\fP"

.PP
Get the list of file cursors of the valid entries, separated by type\&. In the return vector's std::pair<llint, cint>, llint is the index of the cursor in the file, cint is the entry type 
.PP
\fBNote\fP
.RS 4
If the file is not open, the returned vector is empty
.RE
.PP
\fBReturns\fP
.RS 4
(by value) The vector of pairs, each having the (cursor) index and type of each valid entry
.RE
.PP

.PP
Definition at line \fB273\fP of file \fBAELogParser\&.hpp\fP\&.
.SS "bool AELogParser::isClosed (\fBvoid\fP) const\fR [inline]\fP, \fR [noexcept]\fP"

.PP
Checks if the file is closed by the \fBAELogParser\fP\&. 
.PP
\fBSee also\fP
.RS 4
\fBAEFileReader::isClosed()\fP
.RE
.PP
\fBReturns\fP
.RS 4
true is file is closed (no file opened), false otherwise
.RE
.PP

.PP
Definition at line \fB347\fP of file \fBAELogParser\&.hpp\fP\&.
.SS "bool AELogParser::isOpen (\fBvoid\fP) const\fR [inline]\fP, \fR [noexcept]\fP"

.PP
Checks if the file is opened by the \fBAELogParser\fP\&. 
.PP
\fBSee also\fP
.RS 4
\fBAEFileReader::isOpen()\fP
.RE
.PP
\fBReturns\fP
.RS 4
true if file is opened, false otherwise
.RE
.PP

.PP
Definition at line \fB338\fP of file \fBAELogParser\&.hpp\fP\&.
.SS "\fBcint\fP AELogParser::logToQueue (\fBAELogEntry\fP *& begin, \fBconst\fP \fBcint\fP severity = \fR\fBAELOG_TYPE_DEBUG\fP\fP)"

.PP
Same as the \fBAELogParser::nextEntry()\fP but on massive scale -- scans the whole log file and parses it to the freshly-allocated queue\&. 
.PP
\fBWarning\fP
.RS 4
If this queue isn't deallocated (deleted) before dropping the queue pointer, this \fBWILL\fP lead to memory leaks!
.RE
.PP
\fBParameters\fP
.RS 4
\fIbegin\fP The pointer to which the queue will be allocated
.br
\fIseverity\fP The lowest severity of the log to find
.RE
.PP
\fBReturns\fP
.RS 4
AELP_ERR_NOERROR (0) on success, or AEFR_ERR_* (-1 to -8) or AELE_ERR_* (-11 to -15) flags on error
.RE
.PP

.PP
Definition at line \fB85\fP of file \fBAELogParser\&.cpp\fP\&.
.SS "\fBcint\fP AELogParser::nextEntry (\fBAELogEntry\fP & entry, \fBconst\fP \fBcint\fP severity = \fR\fBAELOG_TYPE_DEBUG\fP\fP)"

.PP
Read the next \fIvalid\fP entry in the log file of the given severity filter, and parse it to the given \fBAELogEntry\fP object\&. 
.PP
\fBNote\fP
.RS 4
The severity value just changes the lowest limit of the log severity (lowest by default is debug)\&. If a higher severity is encountered, it's read as well\&. 
.PP
AELOG_TYPE_INVALID works the same as AELOG_TYPE_DEBUG\&. This function parses only \fIvalid\fP entries\&.
.RE
.PP
\fBParameters\fP
.RS 4
\fIentry\fP The log entry object to parse things into
.br
\fIseverity\fP The lowest severity of the log to find
.RE
.PP
\fBReturns\fP
.RS 4
AELP_ERR_NOERROR (0) on success, or AEFR_ERR_* (-1 to -8) or AELE_ERR_* (-11 to -15) flags on error
.RE
.PP

.PP
Definition at line \fB56\fP of file \fBAELogParser\&.cpp\fP\&.
.SS "\fBllint\fP AELogParser::nextEntryCursor (\fBconst\fP \fBcint\fP severity = \fR\fBAELOG_TYPE_DEBUG\fP\fP)\fR [inline]\fP"

.PP
Read the next indexed \fIvalid\fP log entry in the file of the given severity filter and return it's file cursors in the file\&. 
.PP
\fBNote\fP
.RS 4
The severity value just changes the lowest limit of the log severity (lowest by default is debug)\&. If a higher severity is encountered, it's read as well\&. 
.PP
AELOG_TYPE_INVALID works the same as AELOG_TYPE_DEBUG\&. This function parses only \fIvalid\fP entries\&.
.RE
.PP
\fBParameters\fP
.RS 4
\fIseverity\fP The lowest severity of the log to find
.RE
.PP
\fBReturns\fP
.RS 4
The file cursors of the next valid entry (in the currently-opened log file); AEFR_ERR_FILE_NOT_OPEN if the file isn't open
.RE
.PP

.PP
Definition at line \fB174\fP of file \fBAELogParser\&.hpp\fP\&.
.SS "\fBllint\fP AELogParser::nextEntryCursorDebug (\fBvoid\fP)\fR [inline]\fP"

.PP
Read the next indexed valid log entry in the opened file of type 'debug', and return the file cursor to it\&. 
.PP
\fBSee also\fP
.RS 4
\fBAELogParser::nextEntryCursor()\fP
.RE
.PP
\fBReturns\fP
.RS 4
The file cursors of the next valid debug entry (in the currently-opened log file); AEFR_ERR_FILE_NOT_OPEN if the file isn't open
.RE
.PP

.PP
Definition at line \fB194\fP of file \fBAELogParser\&.hpp\fP\&.
.SS "\fBllint\fP AELogParser::nextEntryCursorError (\fBvoid\fP)\fR [inline]\fP"

.PP
Read the next indexed valid log entry in the opened file of type 'rror', and return the file cursor to it\&. 
.PP
\fBSee also\fP
.RS 4
\fBAELogParser::nextEntryCursor()\fP
.RE
.PP
\fBReturns\fP
.RS 4
The file cursors of the next valid rror entry (in the currently-opened log file); AEFR_ERR_FILE_NOT_OPEN if the file isn't open
.RE
.PP

.PP
Definition at line \fB236\fP of file \fBAELogParser\&.hpp\fP\&.
.SS "\fBllint\fP AELogParser::nextEntryCursorFatalError (\fBvoid\fP)\fR [inline]\fP"

.PP
Read the next indexed valid log entry in the opened file of type 'fatal error', and return the file cursor to it\&. 
.PP
\fBSee also\fP
.RS 4
\fBAELogParser::nextEntryCursor()\fP
.RE
.PP
\fBReturns\fP
.RS 4
The file cursors of the next valid fatal error entry (in the currently-opened log file); AEFR_ERR_FILE_NOT_OPEN if the file isn't open
.RE
.PP

.PP
Definition at line \fB243\fP of file \fBAELogParser\&.hpp\fP\&.
.SS "\fBllint\fP AELogParser::nextEntryCursorInfo (\fBvoid\fP)\fR [inline]\fP"

.PP
Read the next indexed valid log entry in the opened file of type 'info', and return the file cursor to it\&. 
.PP
\fBSee also\fP
.RS 4
\fBAELogParser::nextEntryCursor()\fP
.RE
.PP
\fBReturns\fP
.RS 4
The file cursors of the next valid info entry (in the currently-opened log file); AEFR_ERR_FILE_NOT_OPEN if the file isn't open
.RE
.PP

.PP
Definition at line \fB201\fP of file \fBAELogParser\&.hpp\fP\&.
.SS "\fBllint\fP AELogParser::nextEntryCursorOK (\fBvoid\fP)\fR [inline]\fP"

.PP
Read the next indexed valid log entry in the opened file of type 'OK', and return the file cursor to it\&. 
.PP
\fBSee also\fP
.RS 4
\fBAELogParser::nextEntryCursor()\fP
.RE
.PP
\fBReturns\fP
.RS 4
The file cursors of the next valid OK entry (in the currently-opened log file); AEFR_ERR_FILE_NOT_OPEN if the file isn't open
.RE
.PP

.PP
Definition at line \fB222\fP of file \fBAELogParser\&.hpp\fP\&.
.SS "\fBllint\fP AELogParser::nextEntryCursorSevereWarn (\fBvoid\fP)\fR [inline]\fP"

.PP
Read the next indexed valid log entry in the opened file of type 'severe warning', and return the file cursor to it\&. 
.PP
\fBSee also\fP
.RS 4
\fBAELogParser::nextEntryCursor()\fP
.RE
.PP
\fBReturns\fP
.RS 4
The file cursors of the next valid severe warning entry (in the currently-opened log file); AEFR_ERR_FILE_NOT_OPEN if the file isn't open
.RE
.PP

.PP
Definition at line \fB215\fP of file \fBAELogParser\&.hpp\fP\&.
.SS "\fBllint\fP AELogParser::nextEntryCursorSuccess (\fBvoid\fP)\fR [inline]\fP"

.PP
Read the next indexed valid log entry in the opened file of type 'success', and return the file cursor to it\&. 
.PP
\fBSee also\fP
.RS 4
\fBAELogParser::nextEntryCursor()\fP
.RE
.PP
\fBReturns\fP
.RS 4
The file cursors of the next valid success entry (in the currently-opened log file); AEFR_ERR_FILE_NOT_OPEN if the file isn't open
.RE
.PP

.PP
Definition at line \fB229\fP of file \fBAELogParser\&.hpp\fP\&.
.SS "\fBllint\fP AELogParser::nextEntryCursorWarn (\fBvoid\fP)\fR [inline]\fP"

.PP
Read the next indexed valid log entry in the opened file of type 'warning', and return the file cursor to it\&. 
.PP
\fBSee also\fP
.RS 4
\fBAELogParser::nextEntryCursor()\fP
.RE
.PP
\fBReturns\fP
.RS 4
The file cursors of the next valid warning entry (in the currently-opened log file); AEFR_ERR_FILE_NOT_OPEN if the file isn't open
.RE
.PP

.PP
Definition at line \fB208\fP of file \fBAELogParser\&.hpp\fP\&.
.SS "\fBcint\fP AELogParser::nextEntryDebug (\fBAELogEntry\fP & entry)\fR [inline]\fP"

.PP
Read next \fIvalud\fP entry in the log file of 'debug' type, and parse it to the given \fBAELogEntry\fP object\&. 
.PP
\fBSee also\fP
.RS 4
AELogEntry::nextEntry()
.RE
.PP
\fBParameters\fP
.RS 4
\fIentry\fP The log entry object to parse things into
.RE
.PP
\fBReturns\fP
.RS 4
AELP_ERR_NOERROR (0) on success, or AEFR_ERR_* (-1 to -8) or AELE_ERR_* (-11 to -15) flags on error
.RE
.PP

.PP
Definition at line \fB108\fP of file \fBAELogParser\&.hpp\fP\&.
.SS "\fBcint\fP AELogParser::nextEntryError (\fBAELogEntry\fP & entry)\fR [inline]\fP"

.PP
Read next \fIvalud\fP entry in the log file of 'error' type, and parse it to the given \fBAELogEntry\fP object\&. 
.PP
\fBSee also\fP
.RS 4
AELogEntry::nextEntry()
.RE
.PP
\fBParameters\fP
.RS 4
\fIentry\fP The log entry object to parse things into
.RE
.PP
\fBReturns\fP
.RS 4
AELP_ERR_NOERROR (0) on success, or AEFR_ERR_* (-1 to -8) or AELE_ERR_* (-11 to -15) flags on error
.RE
.PP

.PP
Definition at line \fB156\fP of file \fBAELogParser\&.hpp\fP\&.
.SS "\fBcint\fP AELogParser::nextEntryFatalError (\fBAELogEntry\fP & entry)\fR [inline]\fP"

.PP
Read next \fIvalud\fP entry in the log file of 'fatal error' type, and parse it to the given \fBAELogEntry\fP object\&. 
.PP
\fBSee also\fP
.RS 4
AELogEntry::nextEntry()
.RE
.PP
\fBParameters\fP
.RS 4
\fIentry\fP The log entry object to parse things into
.RE
.PP
\fBReturns\fP
.RS 4
AELP_ERR_NOERROR (0) on success, or AEFR_ERR_* (-1 to -8) or AELE_ERR_* (-11 to -15) flags on error
.RE
.PP

.PP
Definition at line \fB164\fP of file \fBAELogParser\&.hpp\fP\&.
.SS "\fBcint\fP AELogParser::nextEntryInfo (\fBAELogEntry\fP & entry)\fR [inline]\fP"

.PP
Read next \fIvalud\fP entry in the log file of 'info' type, and parse it to the given \fBAELogEntry\fP object\&. 
.PP
\fBSee also\fP
.RS 4
AELogEntry::nextEntry()
.RE
.PP
\fBParameters\fP
.RS 4
\fIentry\fP The log entry object to parse things into
.RE
.PP
\fBReturns\fP
.RS 4
AELP_ERR_NOERROR (0) on success, or AEFR_ERR_* (-1 to -8) or AELE_ERR_* (-11 to -15) flags on error
.RE
.PP

.PP
Definition at line \fB116\fP of file \fBAELogParser\&.hpp\fP\&.
.SS "\fBcint\fP AELogParser::nextEntryOK (\fBAELogEntry\fP & entry)\fR [inline]\fP"

.PP
Read next \fIvalud\fP entry in the log file of 'OK' type, and parse it to the given \fBAELogEntry\fP object\&. 
.PP
\fBSee also\fP
.RS 4
AELogEntry::nextEntry()
.RE
.PP
\fBParameters\fP
.RS 4
\fIentry\fP The log entry object to parse things into
.RE
.PP
\fBReturns\fP
.RS 4
AELP_ERR_NOERROR (0) on success, or AEFR_ERR_* (-1 to -8) or AELE_ERR_* (-11 to -15) flags on error
.RE
.PP

.PP
Definition at line \fB140\fP of file \fBAELogParser\&.hpp\fP\&.
.SS "\fBcint\fP AELogParser::nextEntrySevereWarn (\fBAELogEntry\fP & entry)\fR [inline]\fP"

.PP
Read next \fIvalud\fP entry in the log file of 'severe warning' type, and parse it to the given \fBAELogEntry\fP object\&. 
.PP
\fBSee also\fP
.RS 4
AELogEntry::nextEntry()
.RE
.PP
\fBParameters\fP
.RS 4
\fIentry\fP The log entry object to parse things into
.RE
.PP
\fBReturns\fP
.RS 4
AELP_ERR_NOERROR (0) on success, or AEFR_ERR_* (-1 to -8) or AELE_ERR_* (-11 to -15) flags on error
.RE
.PP

.PP
Definition at line \fB132\fP of file \fBAELogParser\&.hpp\fP\&.
.SS "\fBcint\fP AELogParser::nextEntrySuccess (\fBAELogEntry\fP & entry)\fR [inline]\fP"

.PP
Read next \fIvalud\fP entry in the log file of 'success' type, and parse it to the given \fBAELogEntry\fP object\&. 
.PP
\fBSee also\fP
.RS 4
AELogEntry::nextEntry()
.RE
.PP
\fBParameters\fP
.RS 4
\fIentry\fP The log entry object to parse things into
.RE
.PP
\fBReturns\fP
.RS 4
AELP_ERR_NOERROR (0) on success, or AEFR_ERR_* (-1 to -8) or AELE_ERR_* (-11 to -15) flags on error
.RE
.PP

.PP
Definition at line \fB148\fP of file \fBAELogParser\&.hpp\fP\&.
.SS "\fBcint\fP AELogParser::nextEntryWarn (\fBAELogEntry\fP & entry)\fR [inline]\fP"

.PP
Read next \fIvalud\fP entry in the log file of 'warning' type, and parse it to the given \fBAELogEntry\fP object\&. 
.PP
\fBSee also\fP
.RS 4
AELogEntry::nextEntry()
.RE
.PP
\fBParameters\fP
.RS 4
\fIentry\fP The log entry object to parse things into
.RE
.PP
\fBReturns\fP
.RS 4
AELP_ERR_NOERROR (0) on success, or AEFR_ERR_* (-1 to -8) or AELE_ERR_* (-11 to -15) flags on error
.RE
.PP

.PP
Definition at line \fB124\fP of file \fBAELogParser\&.hpp\fP\&.
.SS "\fBcint\fP AELogParser::openLog (\fBconst\fP std::string_view fname)"

.PP
Opens the log file, reading and parsing every single entry, classifying it by type\&. 
.PP
\fBParameters\fP
.RS 4
\fIfname\fP The name of the file to open
.RE
.PP
\fBReturns\fP
.RS 4
AELP_ERR_NOERROR (0) on success, or AEFR_ERR_* (-1 to -8) or AELE_ERR_* (-11 to -15) flags on error
.RE
.PP

.PP
Definition at line \fB10\fP of file \fBAELogParser\&.cpp\fP\&.
.SS "\fBcint\fP AELogParser::setCurrentEntryIndex (\fBconst\fP std::size_t entryIndex)\fR [inline]\fP"

.PP
Definition at line \fB259\fP of file \fBAELogParser\&.hpp\fP\&.
.SH "Member Data Documentation"
.PP 
.SS "std::array<\fBullint\fP, 9> AELogParser::m_arrEntryAmount\fR [private]\fP"

.PP
The amount of log entries read in the file, separated by type/severity\&. 
.PP
Definition at line \fB407\fP of file \fBAELogParser\&.hpp\fP\&.
.SS "\fBAEFileReader\fP AELogParser::m_frLogReader\fR [private]\fP"

.PP
The file reader of the opened log file\&. 
.PP
Definition at line \fB399\fP of file \fBAELogParser\&.hpp\fP\&.
.SS "std::atomic<std::size_t> AELogParser::m_ullCurrentEntry\fR [private]\fP"

.PP
The number corresponding to the currently-read \fIvalid\fP entry in the log file\&. The maximum value corresponds to the size of m_vecEntryIndices 
.PP
Definition at line \fB410\fP of file \fBAELogParser\&.hpp\fP\&.
.SS "std::atomic<\fBullint\fP> \fB__AEModuleBase\fP< \fBAELogParser\fP  >::m_ullModulesAlive\fR [inline]\fP, \fR [static]\fP, \fR [protected]\fP, \fR [inherited]\fP"

.PP
Amount of alive module instances\&. 
.PP
Definition at line \fB100\fP of file \fBAEModuleBase\&.hpp\fP\&.
.SS "std::vector<std::pair<\fBllint\fP, \fBcint\fP> > AELogParser::m_vecEntryIndices\fR [private]\fP"

.PP
The list of all indexed \fIvalid\fP entries in the log file\&. Each item contains their corresponding cursor position in the file and their type/severity\&. 
.PP
Definition at line \fB402\fP of file \fBAELogParser\&.hpp\fP\&.
.SS "std::vector<\fBllint\fP> AELogParser::m_vecInvalidEntryIndices\fR [private]\fP"

.PP
The list of all indexed \fIinvalid\fP entries in the log file Each item contains their corresponding cursor position in the file\&. 
.PP
Definition at line \fB405\fP of file \fBAELogParser\&.hpp\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for ArtyK's Console Engine from the source code\&.

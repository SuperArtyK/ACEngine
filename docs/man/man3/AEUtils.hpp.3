.TH "AEMisc/include/AEUtils.hpp" 3 "Thu Feb 29 2024 20:45:23" "Version v0.0.8.5a" "ArtyK's Console Engine" \" -*- nroff -*-
.ad l
.nh
.SH NAME
AEMisc/include/AEUtils.hpp
.SH SYNOPSIS
.br
.PP
\fR#include 'AEFlags\&.hpp'\fP
.br
\fR#include 'AETypedefs\&.hpp'\fP
.br
\fR#include <algorithm>\fP
.br
\fR#include <iostream>\fP
.br
\fR#include <string>\fP
.br
\fR#include <cstring>\fP
.br
\fR#include <ctime>\fP
.br
\fR#include <sstream>\fP
.br
\fR#include <iomanip>\fP
.br

.SS "Namespaces"

.in +1c
.ti -1c
.RI "namespace \fBace\fP"
.br
.RI "This namespace contains all of things that any of the part of program can use, and is useful\&. "
.ti -1c
.RI "namespace \fBace::utils\fP"
.br
.RI "Global usefull utilities\&. "
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBarrsize\fP(arr)   (sizeof(arr) / sizeof(arr[0]) )"
.br
.RI "Macro for the calculation of static, compile-time array 
.PP
\fBParameters\fP
.RS 4
\fIarr\fP The array to calculate the size of
.RE
.PP
"
.ti -1c
.RI "#define \fBmod0\fP(dividend,  divisor)   !(dividend % divisor)"
.br
.RI "Macro for the check if modulo of x and y results in 0 
.PP
\fBParameters\fP
.RS 4
\fIdividend\fP The dividend of the operation
.br
\fIdivisor\fP The divisor of the operation
.RE
.PP
"
.ti -1c
.RI "#define \fBgetBit\fP(value,  bit)   (value& (1 << bit))"
.br
.RI "Macro to get the bit of the given value (bitwise operations) 
.PP
\fBParameters\fP
.RS 4
\fIvalue\fP The value to get the bit of
.br
\fIbit\fP The bit number to get
.RE
.PP
"
.ti -1c
.RI "#define \fBaceAssert\fP(expression,  message)   if ( !(expression) ) { std::cerr << '\\n\\nAssertion failed!\\nExpression: ' << #expression << '\\nFile: ' << __FILE__ << '\\nLine: ' << __LINE__ << '\\nMessage: ' << message << std::endl; abort(); }"
.br
.RI "Better-fomatted assertion for runtime checks\&. "
.ti -1c
.RI "#define \fBdprintf\fP(\&.\&.\&.)   if constexpr (\fBENGINE_DEBUG\fP) { printf('DEBUG::%s()\-> ', __FUNCTION__); printf(__VA_ARGS__); printf('\\n'); }"
.br
.RI "Macro for the debug printf() printing, use the same way as you have used printf before\&. "
.ti -1c
.RI "#define \fBIS_SAME_NOC\fP(T,  Y)   (std::is_same<typename std::decay<const T>::type, typename std::decay<const Y>::type>::value)"
.br
.RI "Macro to check if the given type T is about the same as Y Evaluates to true if both types (not caring about const-ness) are same\&. "
.ti -1c
.RI "#define \fBUTF8\fP(x)   u8 ## x"
.br
.RI "Macro to convert the normal string literal to utf-8/unicode string literal; u8'Hello World!' 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The string literal to convert to utf8
.RE
.PP
"
.ti -1c
.RI "#define \fBWSTR\fP(x)   L ## x"
.br
.RI "Macro to convert the 'string literal' to L'wide string literal' 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The string literal to convert to wstring
.RE
.PP
"
.ti -1c
.RI "#define \fBSTR\fP(x)   \fB_STR_HELPER\fP(x)"
.br
.RI "Macro to convert the passed non-string literals to a string literal That can be another number macro, or random garbage (abcdef will work too, turns into 'abcdef') "
.ti -1c
.RI "#define \fB_STR_HELPER\fP(x)   #x"
.br
.RI "The macro helper to convert stuff into a string literal\&. "
.ti -1c
.RI "#define \fBaeoffsetof\fP(type,  member)   (intptr_t)&(((type*)NULL)\->member)"
.br
.RI "Offsetof alternative if the compiler doesn't support the offsetof natively 
.PP
\fBParameters\fP
.RS 4
\fItype\fP The type/struct name
.br
\fImember\fP The member of struct/type to calculate the offset between
.RE
.PP
"
.ti -1c
.RI "#define \fBNLC\fP   '\\n'"
.br
.RI "Macro for newline char literal\&. "
.ti -1c
.RI "#define \fBNLS\fP   '\\n'"
.br
.RI "Macro for newline string literal\&. "
.ti -1c
.RI "#define \fBDATETIME_STRING_SIZE\fP   20"
.br
.RI "Size of the string of the formatted date-time by the \fBace::utils::formatDate()\fP "
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "constexpr const char * \fBace::utils::boolToString\fP (const bool b) noexcept"
.br
.RI "Converts bool to the word version\&. "
.ti -1c
.RI "template<typename T , typename Y  = T, typename U  = T> constexpr bool \fBace::utils::isInRange\fP (const T minval, const Y maxval, const U i) noexcept"
.br
.RI "Checks if the value that you passed is within range\&. "
.ti -1c
.RI "void \fBace::utils::toLowerRef\fP (std::string &str1)"
.br
.RI "Lowers the passed std::string by reference\&. "
.ti -1c
.RI "std::string \fBace::utils::toLowerVal\fP (std::string str1)"
.br
.RI "Returns the lowered version of passed std::string\&. "
.ti -1c
.RI "void \fBace::utils::toUpperRef\fP (std::string &str1)"
.br
.RI "Uppers the passed std::string by reference\&. "
.ti -1c
.RI "std::string \fBace::utils::toUpperVal\fP (std::string str1)"
.br
.RI "Returns the uppered version of passed std::string\&. "
.ti -1c
.RI "template<const bool checkFloat = true> constexpr bool \fBace::utils::isNum\fP (const std::string_view strnum) noexcept"
.br
.RI "Checks if the given string is a numerical value\&. "
.ti -1c
.RI "std::string \fBace::utils::formatDate\fP (const time_t timept)"
.br
.RI "Formats the current (c)time point as YYYY-MM-DD\&.HH:mm:SS\&. "
.ti -1c
.RI "char * \fBace::utils::formatDate\fP (const time_t timept, char *const str) noexcept"
.br
.RI "Formats the current (c)time point as YYYY-MM-DD\&.HH:mm:SS\&. "
.ti -1c
.RI "std::string \fBace::utils::getCurrentDate\fP (void)"
.br
.RI "Retrieves the current date and time and formats it in the YYYY-MM-DD\&.HH:mm:SS\&. "
.ti -1c
.RI "time_t \fBace::utils::stringToDate\fP (const char *const timestr, const char *const timeformat='%Y\-%m\-%d\&.%X')"
.br
.ti -1c
.RI "std::string \fBace::utils::addrToStr\fP (const void *const myptr) noexcept"
.br
.RI "Converts the hex address value to string\&. "
.ti -1c
.RI "void \fBace::utils::sleepMS\fP (const int ms) noexcept"
.br
.RI "Convenient sleep function to sleep the thread for ms milliseconds\&. "
.ti -1c
.RI "void \fBace::utils::sleepUS\fP (const int us) noexcept"
.br
.RI "Convenient sleep function to sleep the thread for ms microseconds\&. "
.ti -1c
.RI "std::FILE * \fBace::utils::fopenCC\fP (const char *const fname, const char *const flags) noexcept"
.br
.RI "fopen-cross-compiler --just a cross-compiler wrapper of FILE's fopen to do it properly\&. "
.ti -1c
.RI "constexpr int \fBace::utils::charToInt\fP (const char c) noexcept"
.br
.RI "Converts the given character value to int ('0' to 0), if it is within the '0'->'9' range\&. "
.ti -1c
.RI "constexpr char \fBace::utils::intToChar\fP (const int i) noexcept"
.br
.RI "Converts the given int value to char (0 to '0'), if it is within the 0->9 range\&. "
.ti -1c
.RI "constexpr bool \fBace::utils::isAlNum\fP (const std::string_view str)"
.br
.RI "Checks if the passed string is alpha-numeric (contains only numbers and english letters) "
.ti -1c
.RI "constexpr bool \fBace::utils::isAlNumUs\fP (const std::string_view str)"
.br
.RI "Checks if the passed string is alpha-numeric with underscores (contains only numbers, english letters, and underscores) "
.in -1c
.SH "Detailed Description"
.PP 
This file contains engine function (hopefully useful) utilities\&.
.PP
Should not cause everything to break :) 
.PP
Definition in file \fBAEUtils\&.hpp\fP\&.
.SH "Macro Definition Documentation"
.PP 
.SS "#define _STR_HELPER(x)   #x"

.PP
The macro helper to convert stuff into a string literal\&. 
.PP
\fBSee also\fP
.RS 4
\fBSTR()\fP 
.RE
.PP

.PP
Definition at line \fB89\fP of file \fBAEUtils\&.hpp\fP\&.
.SS "#define aceAssert(expression, message)   if ( !(expression) ) { std::cerr << '\\n\\nAssertion failed!\\nExpression: ' << #expression << '\\nFile: ' << __FILE__ << '\\nLine: ' << __LINE__ << '\\nMessage: ' << message << std::endl; abort(); }"

.PP
Better-fomatted assertion for runtime checks\&. 
.PP
\fBNote\fP
.RS 4
Only works in engine's debug mode\&. Does nothing if ENGINE_DEBUG is not defined and/or set to 1 
.PP
\fBParameters\fP
.RS 4
\fIexpression\fP The logical expression to assert
.br
\fImessage\fP The message to display if the assertion fails
.RE
.PP
.RE
.PP

.PP
Definition at line \fB51\fP of file \fBAEUtils\&.hpp\fP\&.
.SS "#define aeoffsetof(type, member)   (intptr_t)&(((type*)NULL)\->member)"

.PP
Offsetof alternative if the compiler doesn't support the offsetof natively 
.PP
\fBParameters\fP
.RS 4
\fItype\fP The type/struct name
.br
\fImember\fP The member of struct/type to calculate the offset between
.RE
.PP

.PP
Definition at line \fB97\fP of file \fBAEUtils\&.hpp\fP\&.
.SS "#define arrsize(arr)   (sizeof(arr) / sizeof(arr[0]) )"

.PP
Macro for the calculation of static, compile-time array 
.PP
\fBParameters\fP
.RS 4
\fIarr\fP The array to calculate the size of
.RE
.PP

.PP
Definition at line \fB34\fP of file \fBAEUtils\&.hpp\fP\&.
.SS "#define DATETIME_STRING_SIZE   20"

.PP
Size of the string of the formatted date-time by the \fBace::utils::formatDate()\fP 
.PP
Definition at line \fB114\fP of file \fBAEUtils\&.hpp\fP\&.
.SS "#define dprintf( \&.\&.\&.)   if constexpr (\fBENGINE_DEBUG\fP) { printf('DEBUG::%s()\-> ', __FUNCTION__); printf(__VA_ARGS__); printf('\\n'); }"

.PP
Macro for the debug printf() printing, use the same way as you have used printf before\&. 
.PP
\fBNote\fP
.RS 4
Prints additional newline with each print 
.PP
Only works in engine's debug mode\&. Does nothing if ENGINE_DEBUG is not defined and/or set to 1 
.RE
.PP

.PP
Definition at line \fB60\fP of file \fBAEUtils\&.hpp\fP\&.
.SS "#define getBit(value, bit)   (value& (1 << bit))"

.PP
Macro to get the bit of the given value (bitwise operations) 
.PP
\fBParameters\fP
.RS 4
\fIvalue\fP The value to get the bit of
.br
\fIbit\fP The bit number to get
.RE
.PP

.PP
Definition at line \fB44\fP of file \fBAEUtils\&.hpp\fP\&.
.SS "#define IS_SAME_NOC(T, Y)   (std::is_same<typename std::decay<const T>::type, typename std::decay<const Y>::type>::value)"

.PP
Macro to check if the given type T is about the same as Y Evaluates to true if both types (not caring about const-ness) are same\&. 
.PP
\fBNote\fP
.RS 4
It decays both types and omits const-ness 
.PP
\fBParameters\fP
.RS 4
\fIT\fP The first type to compare
.br
\fIY\fP The second type to compare
.RE
.PP
.RE
.PP

.PP
Definition at line \fB70\fP of file \fBAEUtils\&.hpp\fP\&.
.SS "#define mod0(dividend, divisor)   !(dividend % divisor)"

.PP
Macro for the check if modulo of x and y results in 0 
.PP
\fBParameters\fP
.RS 4
\fIdividend\fP The dividend of the operation
.br
\fIdivisor\fP The divisor of the operation
.RE
.PP

.PP
Definition at line \fB39\fP of file \fBAEUtils\&.hpp\fP\&.
.SS "#define NLC   '\\n'"

.PP
Macro for newline char literal\&. 
.PP
Definition at line \fB108\fP of file \fBAEUtils\&.hpp\fP\&.
.SS "#define NLS   '\\n'"

.PP
Macro for newline string literal\&. 
.PP
Definition at line \fB111\fP of file \fBAEUtils\&.hpp\fP\&.
.SS "#define STR(x)   \fB_STR_HELPER\fP(x)"

.PP
Macro to convert the passed non-string literals to a string literal That can be another number macro, or random garbage (abcdef will work too, turns into 'abcdef') 
.PP
\fBWarning\fP
.RS 4
If a string literal was passed, then it will have the quotation marks as escape characters 
.PP
Example STR('abc') will result into '\\'abc\\'' literal 
.PP
Doesn't work on composed macros (macros that consist of other macros within themselves) 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The stuff to convert to a string literal
.RE
.PP
.RE
.PP

.PP
Definition at line \fB85\fP of file \fBAEUtils\&.hpp\fP\&.
.SS "#define UTF8(x)   u8 ## x"

.PP
Macro to convert the normal string literal to utf-8/unicode string literal; u8'Hello World!' 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The string literal to convert to utf8
.RE
.PP

.PP
Definition at line \fB74\fP of file \fBAEUtils\&.hpp\fP\&.
.SS "#define WSTR(x)   L ## x"

.PP
Macro to convert the 'string literal' to L'wide string literal' 
.PP
\fBParameters\fP
.RS 4
\fIx\fP The string literal to convert to wstring
.RE
.PP

.PP
Definition at line \fB77\fP of file \fBAEUtils\&.hpp\fP\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for ArtyK's Console Engine from the source code\&.

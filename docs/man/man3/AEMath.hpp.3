.TH "AEMisc/include/AEMath.hpp" 3 "Thu Feb 29 2024 20:45:23" "Version v0.0.8.5a" "ArtyK's Console Engine" \" -*- nroff -*-
.ad l
.nh
.SH NAME
AEMisc/include/AEMath.hpp
.SH SYNOPSIS
.br
.PP
\fR#include 'AETypedefs\&.hpp'\fP
.br
\fR#include <limits>\fP
.br
\fR#include <cmath>\fP
.br
\fR#include <type_traits>\fP
.br

.SS "Namespaces"

.in +1c
.ti -1c
.RI "namespace \fBace\fP"
.br
.RI "This namespace contains all of things that any of the part of program can use, and is useful\&. "
.ti -1c
.RI "namespace \fBace::math\fP"
.br
.RI "Mathematical functions and other things usefull in math\&. "
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "template<\fBtypename\fP T  = long double> \fBconstexpr\fP T \fBace::math::pi\fP (\fBvoid\fP) \fBnoexcept\fP"
.br
.RI "Engine's pi value\&. "
.ti -1c
.RI "template<\fBtypename\fP T  = long double> \fBconstexpr\fP T \fBace::math::tau\fP (\fBvoid\fP) \fBnoexcept\fP"
.br
.RI "Engine's tau (pi*2) value\&. "
.ti -1c
.RI "template<\fBtypename\fP T  = long double> \fBconstexpr\fP T \fBace::math::piDouble\fP (\fBvoid\fP) \fBnoexcept\fP"
.br
.RI "Engine's pi*2 variable (tau)\&. "
.ti -1c
.RI "template<\fBtypename\fP T  = long double> \fBconstexpr\fP T \fBace::math::piHalf\fP (\fBvoid\fP) \fBnoexcept\fP"
.br
.RI "Engine's pi/2 (half) value\&. "
.ti -1c
.RI "template<\fBtypename\fP T  = long double> \fBconstexpr\fP T \fBace::math::piQuarter\fP (\fBvoid\fP) \fBnoexcept\fP"
.br
.RI "Engine's pi/4 (quarter) value\&. "
.ti -1c
.RI "template<\fBtypename\fP T  = long double> \fBconstexpr\fP T \fBace::math::piSquared\fP (\fBvoid\fP) \fBnoexcept\fP"
.br
.RI "Engine's pi^2 (squared) value\&. "
.ti -1c
.RI "template<\fBtypename\fP T  = long double> \fBconstexpr\fP T \fBace::math::piInv\fP (\fBvoid\fP) \fBnoexcept\fP"
.br
.RI "Engine's 1/pi (inverse) value\&. "
.ti -1c
.RI "template<\fBtypename\fP T  = long double> \fBconstexpr\fP T \fBace::math::log2e\fP (\fBvoid\fP) \fBnoexcept\fP"
.br
.RI "Engine's log2(e) value\&. "
.ti -1c
.RI "template<\fBtypename\fP T  = long double> \fBconstexpr\fP T \fBace::math::log10e\fP (\fBvoid\fP) \fBnoexcept\fP"
.br
.RI "Engine's log10(e) value\&. "
.ti -1c
.RI "template<\fBtypename\fP T  = long double> \fBconstexpr\fP T \fBace::math::ln2\fP (\fBvoid\fP) \fBnoexcept\fP"
.br
.RI "Engine's ln(2) value\&. "
.ti -1c
.RI "template<\fBtypename\fP T  = long double> \fBconstexpr\fP T \fBace::math::ln10\fP (\fBvoid\fP) \fBnoexcept\fP"
.br
.RI "Engine's ln(10) value\&. "
.ti -1c
.RI "template<\fBtypename\fP T  = long double> \fBconstexpr\fP T \fBace::math::sqrtOf2\fP (\fBvoid\fP) \fBnoexcept\fP"
.br
.RI "Engine's sqrt(2) value\&. "
.ti -1c
.RI "template<\fBtypename\fP T  = long double> \fBconstexpr\fP T \fBace::math::sqrtOf3\fP (\fBvoid\fP) \fBnoexcept\fP"
.br
.RI "Engine's sqrt(3) value\&. "
.ti -1c
.RI "template<\fBtypename\fP T  = long double> \fBconstexpr\fP T \fBace::math::sqrtOf2Inv\fP (\fBvoid\fP) \fBnoexcept\fP"
.br
.RI "Engine's 1/sqrt(2) value\&. "
.ti -1c
.RI "template<\fBtypename\fP T  = long double> \fBconstexpr\fP T \fBace::math::sqrtOf3Inv\fP (\fBvoid\fP) \fBnoexcept\fP"
.br
.RI "Engine's 1/sqrt(3) value\&. "
.ti -1c
.RI "template<\fBtypename\fP T  = long double> \fBconstexpr\fP T \fBace::math::sqrtOfPi\fP (\fBvoid\fP) \fBnoexcept\fP"
.br
.RI "Engine's sqrt(pi) value\&. "
.ti -1c
.RI "template<\fBtypename\fP T  = long double> \fBconstexpr\fP T \fBace::math::sqrtOfPiInv\fP (\fBvoid\fP) \fBnoexcept\fP"
.br
.RI "Engine's 1/sqrt(pi) value\&. "
.ti -1c
.RI "template<\fBtypename\fP T  = long double> \fBconstexpr\fP T \fBace::math::e\fP (\fBvoid\fP) \fBnoexcept\fP"
.br
.RI "Engine's euler's number value\&. "
.ti -1c
.RI "template<\fBtypename\fP T  = long double> \fBconstexpr\fP T \fBace::math::eGamma\fP (\fBvoid\fP) \fBnoexcept\fP"
.br
.RI "Engine's euler's gamma function (euler's constant) value\&. "
.ti -1c
.RI "template<\fBtypename\fP T  = long double> \fBconstexpr\fP T \fBace::math::phi\fP (\fBvoid\fP) \fBnoexcept\fP"
.br
.RI "Engine's golden ratio (phi) value\&. "
.ti -1c
.RI "template<\fBtypename\fP T > \fBconstexpr\fP T \fBace::math::toRad\fP (\fBconst\fP T \fBdeg\fP) \fBnoexcept\fP"
.br
.RI "Convert given degrees to radians\&. "
.ti -1c
.RI "template<\fBtypename\fP T > \fBconstexpr\fP T \fBace::math::toDeg\fP (\fBconst\fP T \fBrad\fP) \fBnoexcept\fP"
.br
.RI "Convert given radians to degrees\&. "
.ti -1c
.RI "template<\fBtypename\fP T  = long double> T \fBace::math::sinDeg\fP (\fBconst\fP T \fBdegrees\fP) \fBnoexcept\fP"
.br
.RI "Calculates the sine of the given degrees\&. "
.ti -1c
.RI "template<typename T  = long double> T \fBace::math::cosDeg\fP (const T degrees) noexcept"
.br
.RI "Calculates the cosine of the given degrees\&. "
.ti -1c
.RI "template<\fBtypename\fP T  = long double> T \fBace::math::tanDeg\fP (\fBconst\fP T \fBdegrees\fP) \fBnoexcept\fP"
.br
.RI "Calculates the tangent of the given degrees\&. "
.ti -1c
.RI "template<\fBtypename\fP T  = long double> T \fBace::math::cotDeg\fP (\fBconst\fP T \fBdegrees\fP) \fBnoexcept\fP"
.br
.RI "Calculates the cotangent of the given degrees\&. "
.ti -1c
.RI "template<\fBtypename\fP T  = long double> T \fBace::math::cscDeg\fP (\fBconst\fP T \fBdegrees\fP) \fBnoexcept\fP"
.br
.RI "Calculates the cosecant of the given degrees\&. "
.ti -1c
.RI "template<\fBtypename\fP T  = long double> T \fBace::math::secDeg\fP (\fBconst\fP T \fBdegrees\fP) \fBnoexcept\fP"
.br
.RI "Calculates the secant of the given degrees\&. "
.ti -1c
.RI "template<\fBtypename\fP T > \fBconstexpr\fP T \fBace::math::absval\fP (\fBconst\fP T \fBnum\fP) \fBnoexcept\fP"
.br
.RI "Calculates the absolute value of a given number\&. "
.ti -1c
.RI "template<\fBtypename\fP T  = long double> 
.br
requires (std::is_floating_point<T>\fB::value\fP == \fBtrue\fP)\fBconstexpr\fP bool \fBace::math::fequals\fP (\fBconst\fP T \fBnum\fP, \fBconst\fP T \fBnum2\fP, \fBconst\fP T \fB_epsilon\fP) \fBnoexcept\fP"
.br
.RI "Checks if given 2 floats of type T are equal, using given epsilon\&. "
.ti -1c
.RI "template<\fBtypename\fP T  = long double> 
.br
requires (std::is_floating_point<T>\fB::value\fP == \fBtrue\fP)\fBconstexpr\fP bool \fBace::math::fequals\fP (\fBconst\fP T \fBnum\fP, \fBconst\fP T \fBnum2\fP) \fBnoexcept\fP"
.br
.RI "Checks if given 2 floats of type T are equal, using default epsilon (scaled to current values) "
.ti -1c
.RI "template<\fBtypename\fP T , \fBtypename\fP \fBY\fP  = T> \fBconstexpr\fP bool \fBace::math::equals\fP (\fBconst\fP T &\fBnum\fP, \fBconst\fP \fBY\fP &\fBnum2\fP) \fBnoexcept\fP"
.br
.RI "Checks if given 2 numbers are equal, a generic function for all types\&. "
.ti -1c
.RI "template<\fBtypename\fP T  = long double> \fBconstexpr\fP T \fBace::math::sqrt\fP (\fBconst\fP T \fBnum\fP) \fBnoexcept\fP"
.br
.RI "Newton's method sqrt implementation, compatible with constexpr evaluation\&. "
.ti -1c
.RI "template<\fBtypename\fP T  = long double> \fBconstexpr\fP T \fBace::math::intPow\fP (\fBconst\fP T \fBnum\fP, \fBllint\fP \fBpower\fP) \fBnoexcept\fP"
.br
.RI "Calculate the integer power of a given number\&. "
.ti -1c
.RI "template<\fBtypename\fP T  = long double> \fBconstexpr\fP T \fBace::math::root\fP (\fBconst\fP T \fBnum\fP, \fBconst\fP \fBuint\fP \fBrtNum\fP) \fBnoexcept\fP"
.br
.RI "Calculate the n'th root of a number\&. "
.ti -1c
.RI "template<\fBtypename\fP T , \fBtypename\fP \fBY\fP  = T> \fBconstexpr\fP T \fBace::math::max\fP (\fBconst\fP T &\fBa\fP, \fBconst\fP \fBY\fP &\fBb\fP) \fBnoexcept\fP"
.br
.RI "Gets the biggest value between given two values\&. "
.ti -1c
.RI "template<\fBtypename\fP T , \fBtypename\fP \fBY\fP > \fBconstexpr\fP T \fBace::math::min\fP (\fBconst\fP T &\fBa\fP, \fBconst\fP \fBY\fP &\fBb\fP) \fBnoexcept\fP"
.br
.RI "Gets the smallest value between given two values\&. "
.ti -1c
.RI "template<\fBtypename\fP T > 
.br
requires (std::is_integral<T>\fB::value\fP == \fBtrue\fP)\fBconstexpr\fP \fBunsigned\fP \fBint\fP \fBace::math::lengthOfInt\fP (\fBconst\fP T \fBnum\fP) \fBnoexcept\fP"
.br
.RI "Calculate the length of the given integer number\&. "
.ti -1c
.RI "template<\fBtypename\fP T > 
.br
requires (std::is_floating_point<T>\fB::value\fP == \fBtrue\fP)\fBconstexpr\fP \fBunsigned\fP \fBint\fP \fBace::math::lengthOfFloat\fP (\fBconst\fP T \fBnum\fP) \fBnoexcept\fP"
.br
.RI "Calculate the length of the given float number\&. "
.ti -1c
.RI "template<\fBtypename\fP T  = long double> \fBconstexpr\fP T \fBace::math::lerp\fP (\fBconst\fP T \fBa\fP, \fBconst\fP T \fBb\fP, \fBconst\fP T \fBc\fP)"
.br
.RI "Computes the linear inter/extrapolation with the given values a and b and a value c between or outside of them\&. "
.ti -1c
.RI "template<\fBtypename\fP T  = long double> \fBconstexpr\fP T \fBace::math::hypot\fP (\fBconst\fP T \fBa\fP, \fBconst\fP T \fBb\fP)"
.br
.RI "Calculates the hypotenuse length from given values a and b\&. "
.ti -1c
.RI "template<\fBtypename\fP T  = long double> 
.br
requires (std::is_floating_point<T>\fB::value\fP == \fBtrue\fP)\fBconstexpr\fP bool \fBace::math::isInf\fP (\fBconst\fP T \fBnum\fP) \fBnoexcept\fP"
.br
.RI "Checks whether the float is 'infinite'\&. "
.ti -1c
.RI "template<\fBtypename\fP T  = long double> 
.br
requires (std::is_floating_point<T>\fB::value\fP == \fBtrue\fP)\fBconstexpr\fP bool \fBace::math::isNan\fP (\fBconst\fP T \fBnum\fP) \fBnoexcept\fP"
.br
.RI "Checks whether the float is 'NaN'\&. "
.ti -1c
.RI "template<\fBtypename\fP T  = long double> 
.br
requires (std::is_floating_point<T>\fB::value\fP == \fBtrue\fP)\fBconstexpr\fP bool \fBace::math::isFinite\fP (\fBconst\fP T \fBnum\fP) \fBnoexcept\fP"
.br
.RI "Checks whether the float is finite (not infinity or NaN) "
.ti -1c
.RI "template<\fBtypename\fP T  = llint, \fBtypename\fP \fBY\fP  = long double> \fBconstexpr\fP T \fBace::math::roundToInt\fP (\fBconst\fP \fBY\fP \fBnum\fP) \fBnoexcept\fP"
.br
.RI "Rounds the given float of type Y to integer of type T\&. "
.ti -1c
.RI "template<\fBtypename\fP T  = llint, \fBtypename\fP \fBY\fP  = long double> \fBconstexpr\fP T \fBace::math::floorToInt\fP (\fBconst\fP \fBY\fP \fBnum\fP) \fBnoexcept\fP"
.br
.RI "Floor's the given float of type Y and converts to integer of type T\&. "
.ti -1c
.RI "template<\fBtypename\fP T  = llint, \fBtypename\fP \fBY\fP  = long double> \fBconstexpr\fP T \fBace::math::ceilToInt\fP (\fBconst\fP \fBY\fP \fBnum\fP) \fBnoexcept\fP"
.br
.RI "Ceil's the given float of type Y and converts to integer of type T\&. "
.ti -1c
.RI "template<\fBtypename\fP T  = llint, \fBtypename\fP \fBY\fP  = long double> \fBconstexpr\fP T \fBace::math::truncToInt\fP (\fBconst\fP \fBY\fP \fBnum\fP) \fBnoexcept\fP"
.br
.RI "Truncates the given float of type Y and converts to integer of type T\&. "
.in -1c
.SH "Detailed Description"
.PP 
This file contains the engine math functions, (probably)optimised for engine stuff\&. may be faster or equivalent to what can you find/do yourself\&. And yeah\&.\&.\&.easier to use\&.
.PP
Should not cause everything to break :) 
.PP
Definition in file \fBAEMath\&.hpp\fP\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for ArtyK's Console Engine from the source code\&.

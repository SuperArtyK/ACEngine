.TH "AEMisc/include/AEMath.hpp" 3 "Thu Mar 14 2024 20:55:55" "Version v0.0.8.5a" "ArtyK's Console Engine" \" -*- nroff -*-
.ad l
.nh
.SH NAME
AEMisc/include/AEMath.hpp \- This file contains the engine's \fBmath and math-related functions\fP\&.  

.SH SYNOPSIS
.br
.PP
\fR#include 'AETypedefs\&.hpp'\fP
.br
\fR#include <limits>\fP
.br
\fR#include <cmath>\fP
.br
\fR#include <type_traits>\fP
.br

.SS "Namespaces"

.in +1c
.ti -1c
.RI "namespace \fBace\fP"
.br
.RI "This namespace contains \fBeverything that belongs to the engine\fP\&. "
.ti -1c
.RI "namespace \fBace::math\fP"
.br
.RI "Mathematical functions and other things usefull in math\&. "
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "template<typename T  = long double> constexpr T \fBace::math::pi\fP (void) noexcept"
.br
.RI "Engine's \fBpi\fP value\&. "
.ti -1c
.RI "template<typename T  = long double> constexpr T \fBace::math::tau\fP (void) noexcept"
.br
.RI "Engine's \fBtau (pi*2)\fP value\&. "
.ti -1c
.RI "template<typename T  = long double> constexpr T \fBace::math::piDouble\fP (void) noexcept"
.br
.RI "Engine's \fBpi*2\fP (tau) value Just another name for \fBace::math::tau()\fP "
.ti -1c
.RI "template<typename T  = long double> constexpr T \fBace::math::piHalf\fP (void) noexcept"
.br
.RI "Engine's \fBpi/2\fP (half) value\&. "
.ti -1c
.RI "template<typename T  = long double> constexpr T \fBace::math::piQuarter\fP (void) noexcept"
.br
.RI "Engine's \fBpi/4\fP (quarter) value\&. "
.ti -1c
.RI "template<typename T  = long double> constexpr T \fBace::math::piSquared\fP (void) noexcept"
.br
.RI "Engine's \fBpi^2\fP (squared) value\&. "
.ti -1c
.RI "template<typename T  = long double> constexpr T \fBace::math::piInv\fP (void) noexcept"
.br
.RI "Engine's \fB1/pi\fP (inverse) value\&. "
.ti -1c
.RI "template<typename T  = long double> constexpr T \fBace::math::log2e\fP (void) noexcept"
.br
.RI "Engine's \fBlog2(e)\fP value\&. "
.ti -1c
.RI "template<typename T  = long double> constexpr T \fBace::math::log10e\fP (void) noexcept"
.br
.RI "Engine's \fBlog10(e)\fP value\&. "
.ti -1c
.RI "template<typename T  = long double> constexpr T \fBace::math::ln2\fP (void) noexcept"
.br
.RI "Engine's \fBln(2)\fP value\&. "
.ti -1c
.RI "template<typename T  = long double> constexpr T \fBace::math::ln10\fP (void) noexcept"
.br
.RI "Engine's \fBln(10)\fP value\&. "
.ti -1c
.RI "template<typename T  = long double> constexpr T \fBace::math::sqrtOf2\fP (void) noexcept"
.br
.RI "Engine's \fBsqrt(2)\fP value\&. "
.ti -1c
.RI "template<typename T  = long double> constexpr T \fBace::math::sqrtOf3\fP (void) noexcept"
.br
.RI "Engine's \fBsqrt(3)\fP value\&. "
.ti -1c
.RI "template<typename T  = long double> constexpr T \fBace::math::sqrtOf2Inv\fP (void) noexcept"
.br
.RI "Engine's \fB1/sqrt(2)\fP value\&. "
.ti -1c
.RI "template<typename T  = long double> constexpr T \fBace::math::sqrtOf3Inv\fP (void) noexcept"
.br
.RI "Engine's \fB1/sqrt(3)\fP value\&. "
.ti -1c
.RI "template<typename T  = long double> constexpr T \fBace::math::sqrtOfPi\fP (void) noexcept"
.br
.RI "Engine's \fBsqrt(pi)\fP value\&. "
.ti -1c
.RI "template<typename T  = long double> constexpr T \fBace::math::sqrtOfPiInv\fP (void) noexcept"
.br
.RI "Engine's \fB1/sqrt(pi)\fP value\&. "
.ti -1c
.RI "template<typename T  = long double> constexpr T \fBace::math::e\fP (void) noexcept"
.br
.RI "Engine's \fBeuler's number\fP value\&. "
.ti -1c
.RI "template<typename T  = long double> constexpr T \fBace::math::eGamma\fP (void) noexcept"
.br
.RI "Engine's \fBeuler's gamma function\fP (euler's constant) value\&. "
.ti -1c
.RI "template<typename T  = long double> constexpr T \fBace::math::phi\fP (void) noexcept"
.br
.RI "Engine's \fBgolden ratio\fP (phi) value\&. "
.ti -1c
.RI "template<typename T > constexpr T \fBace::math::toRad\fP (const T deg) noexcept"
.br
.RI "Convert given \fBdegrees to radians\fP "
.ti -1c
.RI "template<typename T  = long double> constexpr bool \fBace::math::isInf\fP (const T num) noexcept"
.br
.RI "Checks \fBif the float is 'infinite'\fP (inf) "
.ti -1c
.RI "template<typename T  = long double> constexpr bool \fBace::math::isNan\fP (const T num) noexcept"
.br
.RI "Checks \fBif the float is 'NaN'\fP "
.ti -1c
.RI "template<typename T  = long double> constexpr bool \fBace::math::isFinite\fP (const T num) noexcept"
.br
.RI "Checks \fBif the float is finite\fP (not infinity or NaN) "
.ti -1c
.RI "template<typename T > constexpr T \fBace::math::toDeg\fP (const T rad) noexcept"
.br
.RI "Convert given \fBradians to degrees\fP "
.ti -1c
.RI "template<typename T  = long double> T \fBace::math::sinDeg\fP (const T degrees) noexcept"
.br
.RI "Calculates the \fBsine of degrees\fP "
.ti -1c
.RI "template<typename T  = long double> T \fBace::math::cosDeg\fP (const T degrees) noexcept"
.br
.RI "Calculates the \fBcosine of degrees\fP "
.ti -1c
.RI "template<typename T  = long double> T \fBace::math::tanDeg\fP (const T degrees) noexcept"
.br
.RI "Calculates the \fBtangent of degrees\fP "
.ti -1c
.RI "template<typename T  = long double> T \fBace::math::cotDeg\fP (const T degrees) noexcept"
.br
.RI "Calculates the \fBcotangent of degrees\fP "
.ti -1c
.RI "template<typename T  = long double> T \fBace::math::cscDeg\fP (const T degrees) noexcept"
.br
.RI "Calculates the \fBcosecant of degrees\fP "
.ti -1c
.RI "template<typename T  = long double> T \fBace::math::secDeg\fP (const T degrees) noexcept"
.br
.RI "Calculates the \fBsecant of degrees\fP "
.ti -1c
.RI "template<typename T > constexpr T \fBace::math::absval\fP (const T num) noexcept"
.br
.RI "Calculates the \fBabsolute value\fP of a given number\&. "
.ti -1c
.RI "template<typename T  = long double> 
.br
requires (std::is_floating_point<T>::value == true)constexpr bool \fBace::math::fequals\fP (const T num, const T num2, const T _epsilon) noexcept"
.br
.RI "\fBCompares two floating\fP point values \fBfor equality\fP, within a given epsilon "
.ti -1c
.RI "template<typename T  = long double> 
.br
requires (std::is_floating_point<T>::value == true)constexpr bool \fBace::math::fequals\fP (const T num, const T num2) noexcept"
.br
.RI "\fBCompares two floating\fP point values \fBfor equality\fP, within a default (scaled) epsilon\&. "
.ti -1c
.RI "template<typename T , typename Y  = T> constexpr bool \fBace::math::equals\fP (const T &num, const Y &num2) noexcept"
.br
.RI "Checks \fBif given 2 numbers are equal\fP, a generic function for all types\&. "
.ti -1c
.RI "template<typename T  = long double> constexpr T \fBace::math::sqrt\fP (const T num) noexcept"
.br
.RI "Newton's method \fBsqrt implementation, compatible with constexpr\fP evaluation\&. "
.ti -1c
.RI "template<typename T  = long double> constexpr T \fBace::math::intPow\fP (const T num, \fBllint\fP power) noexcept"
.br
.RI "Calculate the \fBinteger exponent\fP of a given number\&. "
.ti -1c
.RI "template<typename T  = long double> constexpr T \fBace::math::root\fP (const T num, const \fBuint\fP rtNum) noexcept"
.br
.RI "Calculate the \fBn'th root\fP of a number\&. "
.ti -1c
.RI "template<typename T > constexpr T \fBace::math::max\fP (const T &a, const T &b) noexcept"
.br
.RI "Returns the \fBlargest value\fP between the given two values\&. "
.ti -1c
.RI "template<typename T > constexpr T \fBace::math::min\fP (const T &a, const T &b) noexcept"
.br
.RI "Gets the \fBsmallest value\fP between given two values\&. "
.ti -1c
.RI "template<typename T > 
.br
requires (std::is_integral<T>::value == true)constexpr \fBuint\fP \fBace::math::lengthOfInt\fP (T num) noexcept"
.br
.RI "Calculate the \fBlength of the given integer\fP number\&. "
.ti -1c
.RI "template<typename T > 
.br
requires (std::is_floating_point<T>::value == true)constexpr \fBuint\fP \fBace::math::lengthOfFloat\fP (const T num) noexcept"
.br
.RI "Calculate the \fBlength of the given float\fP number's non-fractional part\&. "
.ti -1c
.RI "template<typename T  = long double> constexpr T \fBace::math::lerp\fP (const T a, const T b, const T c) noexcept"
.br
.RI "Computes the \fBlinear inter/extrapolation\fP with the given interval boundaries a and b, and the interval percentage \fBc\fP\&. "
.ti -1c
.RI "template<typename T  = long double> constexpr T \fBace::math::hypot\fP (const T a, const T b) noexcept"
.br
.RI "Calculates the \fBhypotenuse length\fP from given values a and b\&. "
.ti -1c
.RI "template<typename T  = llint, typename Y  = long double> 
.br
requires (std::is_arithmetic<Y>::value == true && std::is_integral<T>::value == true)constexpr T \fBace::math::roundToInt\fP (const Y num) noexcept"
.br
.RI "\fBRounds the given float\fP of type Y \fBto integer\fP of type T\&. "
.ti -1c
.RI "template<typename T  = llint, typename Y  = long double> 
.br
requires (std::is_arithmetic<Y>::value == true && std::is_integral<T>::value == true)constexpr T \fBace::math::floorToInt\fP (const Y num) noexcept"
.br
.RI "\fBFloor's the given float\fP of type Y and converts \fBto integer\fP of type T\&. "
.ti -1c
.RI "template<typename T  = llint, typename Y  = long double> 
.br
requires (std::is_arithmetic<Y>::value == true && std::is_integral<T>::value == true)constexpr T \fBace::math::ceilToInt\fP (const Y num) noexcept"
.br
.RI "\fBCeil's the given float\fP of type Y and converts \fBto integer\fP of type T\&. "
.ti -1c
.RI "template<typename T  = llint, typename Y  = long double> 
.br
requires (std::is_arithmetic<Y>::value == true && std::is_integral<T>::value == true)constexpr T \fBace::math::truncToInt\fP (const Y num) noexcept"
.br
.RI "\fBTruncates the given float\fP of type Y and converts \fBto integer\fP of type T\&. "
.in -1c
.SH "Detailed Description"
.PP 
This file contains the engine's \fBmath and math-related functions\fP\&. 

These would be quite fast, I tried optimising them for the types that are needed\&.
.PP
Especially with the addition of if-consteval in c++23 (and std::is_constant_evaluated() in c++20) :)
.PP
Since it would be possible to use the constexpr implementations in compile time, 
.br
 and fast (and proper) runtime versions of them at\&.\&.\&.runtime\&.
.PP
\fBDate\fP
.RS 4
2023-2024
.RE
.PP
\fBAuthor\fP
.RS 4
Artemii Kozhemiak (SuperArtyK)
.RE
.PP
\fBCopyright\fP
.RS 4
MIT License
.RE
.PP
\fIShould not cause everything to break :)\fP 
.PP
Definition in file \fBAEMath\&.hpp\fP\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for ArtyK's Console Engine from the source code\&.

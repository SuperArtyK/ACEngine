<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ArtyK&#39;s Console Engine: AELogParser Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript" src="../../darkmode_toggle.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.ico"/></td>
  <td id="projectalign">
   <div id="projectname">ArtyK&#39;s Console Engine<span id="projectnumber">&#160;v0.0.8.5a</span>
   </div>
   <div id="projectbrief">The Console engine for apps and games</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d8/d52/class_a_e_log_parser.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="../../d6/d80/class_a_e_log_parser-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">AELogParser Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>ArtyK's Engine's Log Parser; it parses the log files that <a class="el" href="../../d8/dfc/class_a_e_logger.html" title="The ArtyK&#39;s Engine&#39;s Logger module â€“ it manages the writing to the log files.">AELogger</a> writes.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../d0/dab/_a_e_log_parser_8hpp_source.html">AELogParser.hpp</a>&gt;</code></p>
<div id="dynsection-0" onclick="return dynsection.toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="../../closed.png" alt="+"/> Inheritance diagram for AELogParser:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
 <div class="center">
  <img src="../../d8/d52/class_a_e_log_parser.png" usemap="#AELogParser_map" alt=""/>
  <map id="AELogParser_map" name="AELogParser_map">
<area href="../../d0/d8a/class_____a_e_module_base.html" alt="__AEModuleBase&lt; AELogParser &gt;" shape="rect" coords="0,0,213,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1462a13609f2a9e21a3d337b1e303623" id="r_a1462a13609f2a9e21a3d337b1e303623"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1462a13609f2a9e21a3d337b1e303623">AELogParser</a> (void)</td></tr>
<tr class="memdesc:a1462a13609f2a9e21a3d337b1e303623"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class constructor &ndash; just initialises the object.  <br /></td></tr>
<tr class="separator:a1462a13609f2a9e21a3d337b1e303623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ea4aef815bb40a53a30ed2da94b8c91" id="r_a3ea4aef815bb40a53a30ed2da94b8c91"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3ea4aef815bb40a53a30ed2da94b8c91">AELogParser</a> (const std::string_view fname)</td></tr>
<tr class="memdesc:a3ea4aef815bb40a53a30ed2da94b8c91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class constructor &ndash; opens the file and start the indexing process.  <br /></td></tr>
<tr class="separator:a3ea4aef815bb40a53a30ed2da94b8c91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c35902cdfa4f883d1d8f10dd546f4ed" id="r_a2c35902cdfa4f883d1d8f10dd546f4ed"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c35902cdfa4f883d1d8f10dd546f4ed">~AELogParser</a> (void)</td></tr>
<tr class="memdesc:a2c35902cdfa4f883d1d8f10dd546f4ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class destructor &ndash; closes the log file.  <br /></td></tr>
<tr class="separator:a2c35902cdfa4f883d1d8f10dd546f4ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e90913ac25c938e2e84a9887c5bae66" id="r_a8e90913ac25c938e2e84a9887c5bae66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/d89/_a_e_typedefs_8hpp.html#adabb025f32e720b44bdd40d4e0784710">cint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e90913ac25c938e2e84a9887c5bae66">openLog</a> (const std::string_view fname)</td></tr>
<tr class="memdesc:a8e90913ac25c938e2e84a9887c5bae66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens the log file, reading and parsing every single entry, classifying it by type.  <br /></td></tr>
<tr class="separator:a8e90913ac25c938e2e84a9887c5bae66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad79df0ff0313d4414ce55c13c7078ece" id="r_ad79df0ff0313d4414ce55c13c7078ece"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/d89/_a_e_typedefs_8hpp.html#adabb025f32e720b44bdd40d4e0784710">cint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad79df0ff0313d4414ce55c13c7078ece">closeLog</a> (void)</td></tr>
<tr class="memdesc:ad79df0ff0313d4414ce55c13c7078ece"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the log file and clears the memory.  <br /></td></tr>
<tr class="separator:ad79df0ff0313d4414ce55c13c7078ece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3c28f50c5f52840be97e631d67b244c" id="r_af3c28f50c5f52840be97e631d67b244c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/d89/_a_e_typedefs_8hpp.html#adabb025f32e720b44bdd40d4e0784710">cint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af3c28f50c5f52840be97e631d67b244c">nextEntry</a> (<a class="el" href="../../da/dea/struct_a_e_log_entry.html">AELogEntry</a> &amp;entry, const <a class="el" href="../../dc/d89/_a_e_typedefs_8hpp.html#adabb025f32e720b44bdd40d4e0784710">cint</a> severity=<a class="el" href="../../dc/dd8/_a_e_log_types_8hpp.html#a5a4597f7fb7f605706194f7b98d683e6">AELOG_TYPE_DEBUG</a>, const bool strictSeverity=false, const std::string_view mname=&quot;&quot;)</td></tr>
<tr class="memdesc:af3c28f50c5f52840be97e631d67b244c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the next <em>valid</em> entry in the log file of the given severity and module name filter, and parse it to the given <a class="el" href="../../da/dea/struct_a_e_log_entry.html" title="The structure for the data of the log entry to be manipulated with the log files.">AELogEntry</a> object.  <br /></td></tr>
<tr class="separator:af3c28f50c5f52840be97e631d67b244c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a768d4b94cbf1504d72f93ec5d131e915" id="r_a768d4b94cbf1504d72f93ec5d131e915"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/d89/_a_e_typedefs_8hpp.html#adabb025f32e720b44bdd40d4e0784710">cint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a768d4b94cbf1504d72f93ec5d131e915">nextEntryName</a> (<a class="el" href="../../da/dea/struct_a_e_log_entry.html">AELogEntry</a> &amp;entry, const std::string_view mname)</td></tr>
<tr class="memdesc:a768d4b94cbf1504d72f93ec5d131e915"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the next <em>valid</em> entry in the log file of the given module name, and parse it into the given <a class="el" href="../../da/dea/struct_a_e_log_entry.html" title="The structure for the data of the log entry to be manipulated with the log files.">AELogEntry</a> object.  <br /></td></tr>
<tr class="separator:a768d4b94cbf1504d72f93ec5d131e915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e03f67c2a0eaa0317904a2bd9f70cc0" id="r_a0e03f67c2a0eaa0317904a2bd9f70cc0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/d89/_a_e_typedefs_8hpp.html#adabb025f32e720b44bdd40d4e0784710">cint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e03f67c2a0eaa0317904a2bd9f70cc0">nextEntryType</a> (<a class="el" href="../../da/dea/struct_a_e_log_entry.html">AELogEntry</a> &amp;entry, const <a class="el" href="../../dc/d89/_a_e_typedefs_8hpp.html#adabb025f32e720b44bdd40d4e0784710">cint</a> severity, const bool strictSeverity=false)</td></tr>
<tr class="memdesc:a0e03f67c2a0eaa0317904a2bd9f70cc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the next <em>valid</em> entry in the log file of the given severity, and parse it to the given <a class="el" href="../../da/dea/struct_a_e_log_entry.html" title="The structure for the data of the log entry to be manipulated with the log files.">AELogEntry</a> object.  <br /></td></tr>
<tr class="separator:a0e03f67c2a0eaa0317904a2bd9f70cc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae89b754ad98409469e9b7405f63edee2" id="r_ae89b754ad98409469e9b7405f63edee2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/d89/_a_e_typedefs_8hpp.html#a01c88e5c03ebee098af42984516b9aaf">llint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae89b754ad98409469e9b7405f63edee2">nextEntryCursor</a> (const <a class="el" href="../../dc/d89/_a_e_typedefs_8hpp.html#adabb025f32e720b44bdd40d4e0784710">cint</a> severity=<a class="el" href="../../dc/dd8/_a_e_log_types_8hpp.html#a5a4597f7fb7f605706194f7b98d683e6">AELOG_TYPE_DEBUG</a>, const bool strictSeverity=false, const std::string_view mname=&quot;&quot;)</td></tr>
<tr class="memdesc:ae89b754ad98409469e9b7405f63edee2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the next indexed <em>valid</em> log entry in the file of the given severity and module name filter, and return it's file cursors in the file.  <br /></td></tr>
<tr class="separator:ae89b754ad98409469e9b7405f63edee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e74863a220efa6ca9c3b3067d953469" id="r_a6e74863a220efa6ca9c3b3067d953469"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/d89/_a_e_typedefs_8hpp.html#a01c88e5c03ebee098af42984516b9aaf">llint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e74863a220efa6ca9c3b3067d953469">nextEntryCursorName</a> (const std::string_view mname)</td></tr>
<tr class="memdesc:a6e74863a220efa6ca9c3b3067d953469"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the next indexed <em>valid</em> log entry in the file of the given module name filter, and return it's file cursors in the file.  <br /></td></tr>
<tr class="separator:a6e74863a220efa6ca9c3b3067d953469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff3bcd025e52cd530cbb576d47915c53" id="r_aff3bcd025e52cd530cbb576d47915c53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/d89/_a_e_typedefs_8hpp.html#a01c88e5c03ebee098af42984516b9aaf">llint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff3bcd025e52cd530cbb576d47915c53">nextEntryCursorType</a> (const <a class="el" href="../../dc/d89/_a_e_typedefs_8hpp.html#adabb025f32e720b44bdd40d4e0784710">cint</a> severity, const bool strictSeverity=false)</td></tr>
<tr class="memdesc:aff3bcd025e52cd530cbb576d47915c53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the next indexed <em>valid</em> log entry in the file of the given severity filter and return it's file cursors in the file.  <br /></td></tr>
<tr class="separator:aff3bcd025e52cd530cbb576d47915c53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a997df337f3e8b44e441a804d6b876494" id="r_a997df337f3e8b44e441a804d6b876494"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/d89/_a_e_typedefs_8hpp.html#a01c88e5c03ebee098af42984516b9aaf">llint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a997df337f3e8b44e441a804d6b876494">currentEntryCursor</a> (void) const noexcept</td></tr>
<tr class="memdesc:a997df337f3e8b44e441a804d6b876494"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the file cursors of the current valid entry This entry is the one that was read by a previous call to <a class="el" href="#af3c28f50c5f52840be97e631d67b244c" title="Read the next valid entry in the log file of the given severity and module name filter,...">AELogParser::nextEntry()</a> or AELogParser::getNextEntryIndex()  <br /></td></tr>
<tr class="separator:a997df337f3e8b44e441a804d6b876494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ba4173940c2f7a0bcad84032309e453" id="r_a6ba4173940c2f7a0bcad84032309e453"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ba4173940c2f7a0bcad84032309e453">getCurrentEntryIndex</a> (void) const noexcept</td></tr>
<tr class="memdesc:a6ba4173940c2f7a0bcad84032309e453"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the order number (index) of the current log entry (that was attempted to be read)  <br /></td></tr>
<tr class="separator:a6ba4173940c2f7a0bcad84032309e453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4c1d23fe1fb7303afc76c0e5a6c73b4" id="r_aa4c1d23fe1fb7303afc76c0e5a6c73b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/d89/_a_e_typedefs_8hpp.html#adabb025f32e720b44bdd40d4e0784710">cint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa4c1d23fe1fb7303afc76c0e5a6c73b4">setNextEntryIndex</a> (const std::size_t entryIndex) noexcept</td></tr>
<tr class="memdesc:aa4c1d23fe1fb7303afc76c0e5a6c73b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the order number (index) of the next log entry to be parsed.  <br /></td></tr>
<tr class="separator:aa4c1d23fe1fb7303afc76c0e5a6c73b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3698cc59ff476cb2b5423cd5a54062ff" id="r_a3698cc59ff476cb2b5423cd5a54062ff"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="../../db/d7b/struct_a_e_log_entry_info.html">AELogEntryInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3698cc59ff476cb2b5423cd5a54062ff">getEntryCursorAll</a> (void) const noexcept</td></tr>
<tr class="memdesc:a3698cc59ff476cb2b5423cd5a54062ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the list of file cursors of the valid entries, separated by type.  <br /></td></tr>
<tr class="separator:a3698cc59ff476cb2b5423cd5a54062ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09e70214699c5ab9b26a68dec456ad3b" id="r_a09e70214699c5ab9b26a68dec456ad3b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="../../dc/d89/_a_e_typedefs_8hpp.html#a01c88e5c03ebee098af42984516b9aaf">llint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a09e70214699c5ab9b26a68dec456ad3b">getInvalidEntryCursorAll</a> (void) const noexcept</td></tr>
<tr class="memdesc:a09e70214699c5ab9b26a68dec456ad3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the list of file cursors of the invalid entries.  <br /></td></tr>
<tr class="separator:a09e70214699c5ab9b26a68dec456ad3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a182d51b4aa5771e2e6f6919300e571ca" id="r_a182d51b4aa5771e2e6f6919300e571ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/d89/_a_e_typedefs_8hpp.html#adabb025f32e720b44bdd40d4e0784710">cint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a182d51b4aa5771e2e6f6919300e571ca">logToQueue</a> (<a class="el" href="../../da/dea/struct_a_e_log_entry.html">AELogEntry</a> *&amp;begin, const <a class="el" href="../../dc/d89/_a_e_typedefs_8hpp.html#adabb025f32e720b44bdd40d4e0784710">cint</a> severity=<a class="el" href="../../dc/dd8/_a_e_log_types_8hpp.html#a5a4597f7fb7f605706194f7b98d683e6">AELOG_TYPE_DEBUG</a>, const bool strictSeverity=false, const std::string_view mname=&quot;&quot;)</td></tr>
<tr class="memdesc:a182d51b4aa5771e2e6f6919300e571ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as the <a class="el" href="#af3c28f50c5f52840be97e631d67b244c" title="Read the next valid entry in the log file of the given severity and module name filter,...">AELogParser::nextEntry()</a> but on massive scale &ndash; scans the whole log file and parses it to the freshly-allocated queue.  <br /></td></tr>
<tr class="separator:a182d51b4aa5771e2e6f6919300e571ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab84bb93f08ed48082f74b00290deb308" id="r_ab84bb93f08ed48082f74b00290deb308"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/d89/_a_e_typedefs_8hpp.html#adabb025f32e720b44bdd40d4e0784710">cint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab84bb93f08ed48082f74b00290deb308">logToQueueType</a> (<a class="el" href="../../da/dea/struct_a_e_log_entry.html">AELogEntry</a> *&amp;begin, const <a class="el" href="../../dc/d89/_a_e_typedefs_8hpp.html#adabb025f32e720b44bdd40d4e0784710">cint</a> severity, const bool strictSeverity=false)</td></tr>
<tr class="memdesc:ab84bb93f08ed48082f74b00290deb308"><td class="mdescLeft">&#160;</td><td class="mdescRight">A shortcut to <a class="el" href="#a182d51b4aa5771e2e6f6919300e571ca" title="Same as the AELogParser::nextEntry() but on massive scale â€“ scans the whole log file and parses it to...">AELogParser::logToQueue()</a> to filter only by type/severity of the log entries.  <br /></td></tr>
<tr class="separator:ab84bb93f08ed48082f74b00290deb308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5044cf01623156d91ddc74492b0aeda" id="r_ae5044cf01623156d91ddc74492b0aeda"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/d89/_a_e_typedefs_8hpp.html#adabb025f32e720b44bdd40d4e0784710">cint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae5044cf01623156d91ddc74492b0aeda">logToQueueName</a> (<a class="el" href="../../da/dea/struct_a_e_log_entry.html">AELogEntry</a> *&amp;begin, const std::string_view mname)</td></tr>
<tr class="memdesc:ae5044cf01623156d91ddc74492b0aeda"><td class="mdescLeft">&#160;</td><td class="mdescRight">A shortcut to <a class="el" href="#a182d51b4aa5771e2e6f6919300e571ca" title="Same as the AELogParser::nextEntry() but on massive scale â€“ scans the whole log file and parses it to...">AELogParser::logToQueue()</a> to filter only by the module name of the log entries.  <br /></td></tr>
<tr class="separator:ae5044cf01623156d91ddc74492b0aeda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a490ef241fb6f24144e544e7c2e661d" id="r_a3a490ef241fb6f24144e544e7c2e661d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/d89/_a_e_typedefs_8hpp.html#a689c96cb00098d457d55842c96cc71eb">ullint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3a490ef241fb6f24144e544e7c2e661d">amountEntriesValid</a> (const <a class="el" href="../../dc/d89/_a_e_typedefs_8hpp.html#adabb025f32e720b44bdd40d4e0784710">cint</a> severity=<a class="el" href="../../dc/dd8/_a_e_log_types_8hpp.html#a5a4597f7fb7f605706194f7b98d683e6">AELOG_TYPE_DEBUG</a>) const noexcept</td></tr>
<tr class="memdesc:a3a490ef241fb6f24144e544e7c2e661d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the amount of valid entries in the log (with optional lowest severity setting).  <br /></td></tr>
<tr class="separator:a3a490ef241fb6f24144e544e7c2e661d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa658f338329039cb136f8debd8f2c58" id="r_afa658f338329039cb136f8debd8f2c58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/d89/_a_e_typedefs_8hpp.html#a689c96cb00098d457d55842c96cc71eb">ullint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa658f338329039cb136f8debd8f2c58">amountEntriesInvalid</a> (void) const noexcept</td></tr>
<tr class="memdesc:afa658f338329039cb136f8debd8f2c58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the amount of invalid entries in the log.  <br /></td></tr>
<tr class="separator:afa658f338329039cb136f8debd8f2c58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69ba96647922d2b2996c8b46832a8f3d" id="r_a69ba96647922d2b2996c8b46832a8f3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/d89/_a_e_typedefs_8hpp.html#a689c96cb00098d457d55842c96cc71eb">ullint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a69ba96647922d2b2996c8b46832a8f3d">amountEntriesType</a> (const <a class="el" href="../../dc/d89/_a_e_typedefs_8hpp.html#adabb025f32e720b44bdd40d4e0784710">cint</a> severity) const noexcept</td></tr>
<tr class="memdesc:a69ba96647922d2b2996c8b46832a8f3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the amount of entries of a certain type/severity.  <br /></td></tr>
<tr class="separator:a69ba96647922d2b2996c8b46832a8f3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5533ef9d9c63dd888a955ab39a7bb18f" id="r_a5533ef9d9c63dd888a955ab39a7bb18f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/d89/_a_e_typedefs_8hpp.html#a689c96cb00098d457d55842c96cc71eb">ullint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5533ef9d9c63dd888a955ab39a7bb18f">amountEntriesName</a> (const std::string_view mname) const noexcept</td></tr>
<tr class="memdesc:a5533ef9d9c63dd888a955ab39a7bb18f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the amount of entries of a certain module name.  <br /></td></tr>
<tr class="separator:a5533ef9d9c63dd888a955ab39a7bb18f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04627d27deedd7981a5e106dd8ade5ed" id="r_a04627d27deedd7981a5e106dd8ade5ed"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a04627d27deedd7981a5e106dd8ade5ed">containsSeverity</a> (const <a class="el" href="../../dc/d89/_a_e_typedefs_8hpp.html#adabb025f32e720b44bdd40d4e0784710">cint</a> severity, const bool strictSeverity=false) const noexcept</td></tr>
<tr class="memdesc:a04627d27deedd7981a5e106dd8ade5ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the current log file contains the given severity (or higher, depending on the "strict-severity" flag)  <br /></td></tr>
<tr class="separator:a04627d27deedd7981a5e106dd8ade5ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a318c93562f4b8d14aff66a63998bf157" id="r_a318c93562f4b8d14aff66a63998bf157"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a318c93562f4b8d14aff66a63998bf157">isOpen</a> (void) const noexcept</td></tr>
<tr class="memdesc:a318c93562f4b8d14aff66a63998bf157"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the file is opened by the <a class="el" href="../../d8/d52/class_a_e_log_parser.html" title="ArtyK&#39;s Engine&#39;s Log Parser; it parses the log files that AELogger writes.">AELogParser</a>.  <br /></td></tr>
<tr class="separator:a318c93562f4b8d14aff66a63998bf157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af349b880be4cdd8c6d27960a038680ab" id="r_af349b880be4cdd8c6d27960a038680ab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af349b880be4cdd8c6d27960a038680ab">isClosed</a> (void) const noexcept</td></tr>
<tr class="memdesc:af349b880be4cdd8c6d27960a038680ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the file is closed by the <a class="el" href="../../d8/d52/class_a_e_log_parser.html" title="ArtyK&#39;s Engine&#39;s Log Parser; it parses the log files that AELogger writes.">AELogParser</a>.  <br /></td></tr>
<tr class="separator:af349b880be4cdd8c6d27960a038680ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6408e9d9b209c88d32d340a76160c12e" id="r_a6408e9d9b209c88d32d340a76160c12e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6408e9d9b209c88d32d340a76160c12e">getFullFileName</a> (void) const noexcept</td></tr>
<tr class="memdesc:a6408e9d9b209c88d32d340a76160c12e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the full name of currently open file, including the relative path, if such was provided.  <br /></td></tr>
<tr class="separator:a6408e9d9b209c88d32d340a76160c12e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a1f374dbcebcbe44497d593247ac8c6" id="r_a0a1f374dbcebcbe44497d593247ac8c6"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0a1f374dbcebcbe44497d593247ac8c6">getRelativePath</a> (void) const</td></tr>
<tr class="memdesc:a0a1f374dbcebcbe44497d593247ac8c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the relative path of the opened file.  <br /></td></tr>
<tr class="separator:a0a1f374dbcebcbe44497d593247ac8c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63a04021dcd2c31540c50182f8912c9d" id="r_a63a04021dcd2c31540c50182f8912c9d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a63a04021dcd2c31540c50182f8912c9d">getFileName</a> (void) const</td></tr>
<tr class="memdesc:a63a04021dcd2c31540c50182f8912c9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of the opened file, devoid of the path.  <br /></td></tr>
<tr class="separator:a63a04021dcd2c31540c50182f8912c9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b852e7f006c6414580aaec49dab321a" id="r_a8b852e7f006c6414580aaec49dab321a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b852e7f006c6414580aaec49dab321a">getFullPath</a> (void) const</td></tr>
<tr class="memdesc:a8b852e7f006c6414580aaec49dab321a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the full, absolute path of the opened file.  <br /></td></tr>
<tr class="separator:a8b852e7f006c6414580aaec49dab321a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44ec617b1dfe73f33a25a72172e69a95" id="r_a44ec617b1dfe73f33a25a72172e69a95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dd/dd5/class_a_e_file_reader.html">AEFileReader</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a44ec617b1dfe73f33a25a72172e69a95">getFileReader</a> (void) noexcept</td></tr>
<tr class="memdesc:a44ec617b1dfe73f33a25a72172e69a95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the reference to the <a class="el" href="../../dd/dd5/class_a_e_file_reader.html" title="ArtyK&#39;s Engine File Reader; umm, it reads data from the given file.">AEFileReader</a> object of this instance of <a class="el" href="../../d8/d52/class_a_e_log_parser.html" title="ArtyK&#39;s Engine&#39;s Log Parser; it parses the log files that AELogger writes.">AELogParser</a>.  <br /></td></tr>
<tr class="separator:a44ec617b1dfe73f33a25a72172e69a95"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a7c3e2c0736eb6a3ccd84a528d72835ad" id="r_a7c3e2c0736eb6a3ccd84a528d72835ad"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../dc/d89/_a_e_typedefs_8hpp.html#adabb025f32e720b44bdd40d4e0784710">cint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7c3e2c0736eb6a3ccd84a528d72835ad">filterQueue</a> (<a class="el" href="../../da/dea/struct_a_e_log_entry.html">AELogEntry</a> *&amp;ptr, const <a class="el" href="../../dc/d89/_a_e_typedefs_8hpp.html#adabb025f32e720b44bdd40d4e0784710">cint</a> severity, const bool strictSeverity, const std::string_view mname, const bool reallocQueue=true)</td></tr>
<tr class="memdesc:a7c3e2c0736eb6a3ccd84a528d72835ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters the passed queue according to the given severity and modulename filters.  <br /></td></tr>
<tr class="separator:a7c3e2c0736eb6a3ccd84a528d72835ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8545d9e179171cd0ea6cf462c755715" id="r_ae8545d9e179171cd0ea6cf462c755715"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../dc/d89/_a_e_typedefs_8hpp.html#adabb025f32e720b44bdd40d4e0784710">cint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae8545d9e179171cd0ea6cf462c755715">filterQueueType</a> (<a class="el" href="../../da/dea/struct_a_e_log_entry.html">AELogEntry</a> *&amp;ptr, const <a class="el" href="../../dc/d89/_a_e_typedefs_8hpp.html#adabb025f32e720b44bdd40d4e0784710">cint</a> severity, const bool strictSeverity=false, const bool reallocQueue=true)</td></tr>
<tr class="memdesc:ae8545d9e179171cd0ea6cf462c755715"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters the passed queue according to the given severity.  <br /></td></tr>
<tr class="separator:ae8545d9e179171cd0ea6cf462c755715"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89fbdf373de904d275768e4eb15432c7" id="r_a89fbdf373de904d275768e4eb15432c7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../dc/d89/_a_e_typedefs_8hpp.html#adabb025f32e720b44bdd40d4e0784710">cint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a89fbdf373de904d275768e4eb15432c7">filterQueueName</a> (<a class="el" href="../../da/dea/struct_a_e_log_entry.html">AELogEntry</a> *&amp;ptr, const std::string_view mname, const bool reallocQueue=true)</td></tr>
<tr class="memdesc:a89fbdf373de904d275768e4eb15432c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters the passed queue according to the given modulename.  <br /></td></tr>
<tr class="separator:a89fbdf373de904d275768e4eb15432c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3257ef44350e547976d6199ffdb743f" id="r_ab3257ef44350e547976d6199ffdb743f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../dc/d89/_a_e_typedefs_8hpp.html#a689c96cb00098d457d55842c96cc71eb">ullint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d8a/class_____a_e_module_base.html#ab3257ef44350e547976d6199ffdb743f">getModuleAmount</a> (void) noexcept</td></tr>
<tr class="memdesc:ab3257ef44350e547976d6199ffdb743f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the amount of instances of the module currently existing.  <br /></td></tr>
<tr class="separator:ab3257ef44350e547976d6199ffdb743f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f3461ab9cf4aa231ba93ce28f7f856c" id="r_a2f3461ab9cf4aa231ba93ce28f7f856c"><td class="memItemLeft" align="right" valign="top">static constexpr std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d8a/class_____a_e_module_base.html#a2f3461ab9cf4aa231ba93ce28f7f856c">getModuleName</a> (void) noexcept</td></tr>
<tr class="memdesc:a2f3461ab9cf4aa231ba93ce28f7f856c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of the registered module.  <br /></td></tr>
<tr class="separator:a2f3461ab9cf4aa231ba93ce28f7f856c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-static-attribs" name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:aa6b53ab9e5c623900a03d4ea16eb5a99" id="r_aa6b53ab9e5c623900a03d4ea16eb5a99"><td class="memItemLeft" align="right" valign="top">static std::atomic&lt; std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d8a/class_____a_e_module_base.html#aa6b53ab9e5c623900a03d4ea16eb5a99">m_ullModulesAlive</a></td></tr>
<tr class="memdesc:aa6b53ab9e5c623900a03d4ea16eb5a99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Amount of alive module instances.  <br /></td></tr>
<tr class="separator:aa6b53ab9e5c623900a03d4ea16eb5a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:afcff7caee18bdcafa1dc0edb75a75590" id="r_afcff7caee18bdcafa1dc0edb75a75590"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../db/d7b/struct_a_e_log_entry_info.html">AELogEntryInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afcff7caee18bdcafa1dc0edb75a75590">findNextEntry</a> (const <a class="el" href="../../dc/d89/_a_e_typedefs_8hpp.html#adabb025f32e720b44bdd40d4e0784710">cint</a> severity, const std::string_view mname, const bool strictSeverity)</td></tr>
<tr class="memdesc:afcff7caee18bdcafa1dc0edb75a75590"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the <a class="el" href="../../db/d7b/struct_a_e_log_entry_info.html" title="The struct that holds the information about the log entry, used by AELogParser.">AELogEntryInfo</a> corresponding to the next log entry with the specified severity and module name.  <br /></td></tr>
<tr class="separator:afcff7caee18bdcafa1dc0edb75a75590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfe665d273e635559e15339dd34bace5" id="r_abfe665d273e635559e15339dd34bace5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abfe665d273e635559e15339dd34bace5">REGISTER_MODULE</a> (<a class="el" href="../../d8/d52/class_a_e_log_parser.html">AELogParser</a>)</td></tr>
<tr class="separator:abfe665d273e635559e15339dd34bace5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-static-methods" name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:a77b12a5ddd2933a8319e523986788292" id="r_a77b12a5ddd2933a8319e523986788292"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="../../dc/d89/_a_e_typedefs_8hpp.html#adabb025f32e720b44bdd40d4e0784710">cint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a77b12a5ddd2933a8319e523986788292">errorFromAELEI</a> (const <a class="el" href="../../db/d7b/struct_a_e_log_entry_info.html">AELogEntryInfo</a> &amp;leInfo) noexcept</td></tr>
<tr class="memdesc:a77b12a5ddd2933a8319e523986788292"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the error codes from the invalid values in the passed <a class="el" href="../../db/d7b/struct_a_e_log_entry_info.html" title="The struct that holds the information about the log entry, used by AELogParser.">AELogEntryInfo</a> instance.  <br /></td></tr>
<tr class="separator:a77b12a5ddd2933a8319e523986788292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21f7748ae4be67f2221a114cbe9bca7c" id="r_a21f7748ae4be67f2221a114cbe9bca7c"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a21f7748ae4be67f2221a114cbe9bca7c">checkSeverity</a> (const <a class="el" href="../../dc/d89/_a_e_typedefs_8hpp.html#adabb025f32e720b44bdd40d4e0784710">cint</a> entrySeverity, const <a class="el" href="../../dc/d89/_a_e_typedefs_8hpp.html#adabb025f32e720b44bdd40d4e0784710">cint</a> filterSeverity, const bool strictSeverity=false) noexcept</td></tr>
<tr class="memdesc:a21f7748ae4be67f2221a114cbe9bca7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the passed severity is valid compared to the filtering severity.  <br /></td></tr>
<tr class="separator:a21f7748ae4be67f2221a114cbe9bca7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e16a086fe0cb5cc6828b53b0a97a1bf" id="r_a8e16a086fe0cb5cc6828b53b0a97a1bf"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e16a086fe0cb5cc6828b53b0a97a1bf">checkMName</a> (const short entryNameIndex, const short filterNameIndex) noexcept</td></tr>
<tr class="memdesc:a8e16a086fe0cb5cc6828b53b0a97a1bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the passed entry's and filter's module name indices match Moved from a lambda, so it's easier to use with other parts of the log parser.  <br /></td></tr>
<tr class="separator:a8e16a086fe0cb5cc6828b53b0a97a1bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a7a38c688d9485750a19f272ceee513fd" id="r_a7a38c688d9485750a19f272ceee513fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dd/dd5/class_a_e_file_reader.html">AEFileReader</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7a38c688d9485750a19f272ceee513fd">m_frLogReader</a></td></tr>
<tr class="memdesc:a7a38c688d9485750a19f272ceee513fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The file reader of the opened log file.  <br /></td></tr>
<tr class="separator:a7a38c688d9485750a19f272ceee513fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a230f2b4ee8b95592fee2a627e0412c7d" id="r_a230f2b4ee8b95592fee2a627e0412c7d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="../../db/d7b/struct_a_e_log_entry_info.html">AELogEntryInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a230f2b4ee8b95592fee2a627e0412c7d">m_vecEntryIndices</a></td></tr>
<tr class="memdesc:a230f2b4ee8b95592fee2a627e0412c7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The list of all indexed <em>valid</em> entries in the log file.  <br /></td></tr>
<tr class="separator:a230f2b4ee8b95592fee2a627e0412c7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafdf325ac835c82df04ce2d327f820c8" id="r_aafdf325ac835c82df04ce2d327f820c8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="../../dc/d89/_a_e_typedefs_8hpp.html#a01c88e5c03ebee098af42984516b9aaf">llint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aafdf325ac835c82df04ce2d327f820c8">m_vecInvalidEntryIndices</a></td></tr>
<tr class="memdesc:aafdf325ac835c82df04ce2d327f820c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The list of all indexed <em>invalid</em> entries in the log file Each item contains their corresponding cursor position in the file.  <br /></td></tr>
<tr class="separator:aafdf325ac835c82df04ce2d327f820c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8013f4b6fa684c9b2346835e1ab1d84f" id="r_a8013f4b6fa684c9b2346835e1ab1d84f"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; std::string, std::pair&lt; <a class="el" href="../../dc/d89/_a_e_typedefs_8hpp.html#a689c96cb00098d457d55842c96cc71eb">ullint</a>, short &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8013f4b6fa684c9b2346835e1ab1d84f">m_mapModuleNames</a></td></tr>
<tr class="memdesc:a8013f4b6fa684c9b2346835e1ab1d84f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The map of the all module names parsed in the log file.  <br /></td></tr>
<tr class="separator:a8013f4b6fa684c9b2346835e1ab1d84f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c7c7db04ea7f316e6c8905d6bb43984" id="r_a9c7c7db04ea7f316e6c8905d6bb43984"><td class="memItemLeft" align="right" valign="top">std::array&lt; <a class="el" href="../../dc/d89/_a_e_typedefs_8hpp.html#a689c96cb00098d457d55842c96cc71eb">ullint</a>, 9 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9c7c7db04ea7f316e6c8905d6bb43984">m_arrEntryAmount</a></td></tr>
<tr class="memdesc:a9c7c7db04ea7f316e6c8905d6bb43984"><td class="mdescLeft">&#160;</td><td class="mdescRight">The amount of log entries read in the file, separated by type/severity.  <br /></td></tr>
<tr class="separator:a9c7c7db04ea7f316e6c8905d6bb43984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61389d7cbc5253a1ee578d8be67ea078" id="r_a61389d7cbc5253a1ee578d8be67ea078"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a61389d7cbc5253a1ee578d8be67ea078">m_ullCurrentEntry</a></td></tr>
<tr class="memdesc:a61389d7cbc5253a1ee578d8be67ea078"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number corresponding to the currently-read <em>valid</em> entry in the log file.  <br /></td></tr>
<tr class="separator:a61389d7cbc5253a1ee578d8be67ea078"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>ArtyK's Engine's Log Parser; it parses the log files that <a class="el" href="../../d8/dfc/class_a_e_logger.html" title="The ArtyK&#39;s Engine&#39;s Logger module â€“ it manages the writing to the log files.">AELogger</a> writes. </p>
<p>Wrapper around <a class="el" href="../../da/dea/struct_a_e_log_entry.html" title="The structure for the data of the log entry to be manipulated with the log files.">AELogEntry</a> for parsing and <a class="el" href="../../db/d15/class_a_e_file_writer.html" title="ArtyK&#39;s Engine File Writer; umm, it writes data to given file.">AEFileWriter</a> for reading functionality, (ab)using them both.</p>
<p>When opening a file, it reads it and indexes it for log information, and after the parsing/reading the log file to memory can be requested (one entry at a time/the whole thing). Such info would be the amount of entries, amount of entries of each type, etc. Also it allows to filter the log by severity and read only important (to the use-case) data.</p>
<p>Hungarian notation is lp. (m_lpMyLogParser) Flags start with AELP_ </p>

<p class="definition">Definition at line <a class="el" href="../../d0/dab/_a_e_log_parser_8hpp_source.html#l00066">66</a> of file <a class="el" href="../../d0/dab/_a_e_log_parser_8hpp_source.html">AELogParser.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a1462a13609f2a9e21a3d337b1e303623" name="a1462a13609f2a9e21a3d337b1e303623"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1462a13609f2a9e21a3d337b1e303623">&#9670;&#160;</a></span>AELogParser() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">AELogParser::AELogParser </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Class constructor &ndash; just initialises the object. </p>

<p class="definition">Definition at line <a class="el" href="../../d0/dab/_a_e_log_parser_8hpp_source.html#l00073">73</a> of file <a class="el" href="../../d0/dab/_a_e_log_parser_8hpp_source.html">AELogParser.hpp</a>.</p>

</div>
</div>
<a id="a3ea4aef815bb40a53a30ed2da94b8c91" name="a3ea4aef815bb40a53a30ed2da94b8c91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ea4aef815bb40a53a30ed2da94b8c91">&#9670;&#160;</a></span>AELogParser() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">AELogParser::AELogParser </td>
          <td>(</td>
          <td class="paramtype">const std::string_view</td>          <td class="paramname"><span class="paramname"><em>fname</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Class constructor &ndash; opens the file and start the indexing process. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fname</td><td>The name of the file to open</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d0/dab/_a_e_log_parser_8hpp_source.html#l00081">81</a> of file <a class="el" href="../../d0/dab/_a_e_log_parser_8hpp_source.html">AELogParser.hpp</a>.</p>

</div>
</div>
<a id="a2c35902cdfa4f883d1d8f10dd546f4ed" name="a2c35902cdfa4f883d1d8f10dd546f4ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c35902cdfa4f883d1d8f10dd546f4ed">&#9670;&#160;</a></span>~AELogParser()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">AELogParser::~AELogParser </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Class destructor &ndash; closes the log file. </p>

<p class="definition">Definition at line <a class="el" href="../../d0/dab/_a_e_log_parser_8hpp_source.html#l00090">90</a> of file <a class="el" href="../../d0/dab/_a_e_log_parser_8hpp_source.html">AELogParser.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="afa658f338329039cb136f8debd8f2c58" name="afa658f338329039cb136f8debd8f2c58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa658f338329039cb136f8debd8f2c58">&#9670;&#160;</a></span>amountEntriesInvalid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d89/_a_e_typedefs_8hpp.html#a689c96cb00098d457d55842c96cc71eb">ullint</a> AELogParser::amountEntriesInvalid </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the amount of invalid entries in the log. </p>
<p>Invalid entries are of type AELOG_TYPE_INVALID</p>
<dl class="section return"><dt>Returns</dt><dd>ullint amount of invalid entries</dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d0/dab/_a_e_log_parser_8hpp_source.html#l00353">353</a> of file <a class="el" href="../../d0/dab/_a_e_log_parser_8hpp_source.html">AELogParser.hpp</a>.</p>

</div>
</div>
<a id="a5533ef9d9c63dd888a955ab39a7bb18f" name="a5533ef9d9c63dd888a955ab39a7bb18f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5533ef9d9c63dd888a955ab39a7bb18f">&#9670;&#160;</a></span>amountEntriesName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d89/_a_e_typedefs_8hpp.html#a689c96cb00098d457d55842c96cc71eb">ullint</a> AELogParser::amountEntriesName </td>
          <td>(</td>
          <td class="paramtype">const std::string_view</td>          <td class="paramname"><span class="paramname"><em>mname</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the amount of entries of a certain module name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mname</td><td>The module name of the log entries to search for&lt;</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Amount of entries with a certain module name; ULLINT_MAX if the modulename wasn't found</dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d0/dab/_a_e_log_parser_8hpp_source.html#l00374">374</a> of file <a class="el" href="../../d0/dab/_a_e_log_parser_8hpp_source.html">AELogParser.hpp</a>.</p>

</div>
</div>
<a id="a69ba96647922d2b2996c8b46832a8f3d" name="a69ba96647922d2b2996c8b46832a8f3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69ba96647922d2b2996c8b46832a8f3d">&#9670;&#160;</a></span>amountEntriesType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d89/_a_e_typedefs_8hpp.html#a689c96cb00098d457d55842c96cc71eb">ullint</a> AELogParser::amountEntriesType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/d89/_a_e_typedefs_8hpp.html#adabb025f32e720b44bdd40d4e0784710">cint</a></td>          <td class="paramname"><span class="paramname"><em>severity</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the amount of entries of a certain type/severity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">severity</td><td>The severity/type of the log to find</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ullint amount of entries on success; ULLINT_MAX if the severity is outside of the AELOG_TYPE_* range</dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d0/dab/_a_e_log_parser_8hpp_source.html#l00362">362</a> of file <a class="el" href="../../d0/dab/_a_e_log_parser_8hpp_source.html">AELogParser.hpp</a>.</p>

</div>
</div>
<a id="a3a490ef241fb6f24144e544e7c2e661d" name="a3a490ef241fb6f24144e544e7c2e661d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a490ef241fb6f24144e544e7c2e661d">&#9670;&#160;</a></span>amountEntriesValid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d89/_a_e_typedefs_8hpp.html#a689c96cb00098d457d55842c96cc71eb">ullint</a> AELogParser::amountEntriesValid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/d89/_a_e_typedefs_8hpp.html#adabb025f32e720b44bdd40d4e0784710">cint</a></td>          <td class="paramname"><span class="paramname"><em>severity</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="../../dc/dd8/_a_e_log_types_8hpp.html#a5a4597f7fb7f605706194f7b98d683e6">AELOG_TYPE_DEBUG</a></span></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the amount of valid entries in the log (with optional lowest severity setting). </p>
<p>Valid entries are entries that are not AELOG_TYPE_INVALID</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">severity</td><td>The lowest severity of the log to find</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ULLINT_MAX if the severity is outside of the AELOG_TYPE_* range; ullint amount of entries</dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d0/dab/_a_e_log_parser_8hpp_source.html#l00338">338</a> of file <a class="el" href="../../d0/dab/_a_e_log_parser_8hpp_source.html">AELogParser.hpp</a>.</p>

</div>
</div>
<a id="a8e16a086fe0cb5cc6828b53b0a97a1bf" name="a8e16a086fe0cb5cc6828b53b0a97a1bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e16a086fe0cb5cc6828b53b0a97a1bf">&#9670;&#160;</a></span>checkMName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr bool AELogParser::checkMName </td>
          <td>(</td>
          <td class="paramtype">const short</td>          <td class="paramname"><span class="paramname"><em>entryNameIndex</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const short</td>          <td class="paramname"><span class="paramname"><em>filterNameIndex</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the passed entry's and filter's module name indices match Moved from a lambda, so it's easier to use with other parts of the log parser. </p>
<dl class="section note"><dt>Note</dt><dd>If filterNameIndex is 0, then it will always return true (we aren't checking for it)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entryNameIndex</td><td>The module name index of the entry</td></tr>
    <tr><td class="paramname">filterNameIndex</td><td>The module name index filter</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d0/dab/_a_e_log_parser_8hpp_source.html#l00534">534</a> of file <a class="el" href="../../d0/dab/_a_e_log_parser_8hpp_source.html">AELogParser.hpp</a>.</p>

</div>
</div>
<a id="a21f7748ae4be67f2221a114cbe9bca7c" name="a21f7748ae4be67f2221a114cbe9bca7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21f7748ae4be67f2221a114cbe9bca7c">&#9670;&#160;</a></span>checkSeverity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr bool AELogParser::checkSeverity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/d89/_a_e_typedefs_8hpp.html#adabb025f32e720b44bdd40d4e0784710">cint</a></td>          <td class="paramname"><span class="paramname"><em>entrySeverity</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dc/d89/_a_e_typedefs_8hpp.html#adabb025f32e720b44bdd40d4e0784710">cint</a></td>          <td class="paramname"><span class="paramname"><em>filterSeverity</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>strictSeverity</em><span class="paramdefsep"> = </span><span class="paramdefval">false</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the passed severity is valid compared to the filtering severity. </p>
<p>Moved from a lambda, so it's easier to use with other parts of the log parser. </p><dl class="section note"><dt>Note</dt><dd>If strictSeverity is true, performs exact check. Otherwise if the passed entrySeverity is more or equal to the filtering filterSeverity. </dd>
<dd>
If filterSeverity is AELP_SEVERITY_ALL, the function always returns true</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">strictSeverity</td><td>Whether to check if both severity levels <em>match exactly</em>. Default: false</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entrySeverity</td><td>The severity to check/filter</td></tr>
    <tr><td class="paramname">filterSeverity</td><td>The filtering severity</td></tr>
    <tr><td class="paramname">strictSeverity</td><td>The flag to indicate whether the severity check should be strict (exact)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the filtering conditions are satisfied; false otherwise</dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d0/dab/_a_e_log_parser_8hpp_source.html#l00516">516</a> of file <a class="el" href="../../d0/dab/_a_e_log_parser_8hpp_source.html">AELogParser.hpp</a>.</p>

</div>
</div>
<a id="ad79df0ff0313d4414ce55c13c7078ece" name="ad79df0ff0313d4414ce55c13c7078ece"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad79df0ff0313d4414ce55c13c7078ece">&#9670;&#160;</a></span>closeLog()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d89/_a_e_typedefs_8hpp.html#adabb025f32e720b44bdd40d4e0784710">cint</a> AELogParser::closeLog </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Closes the log file and clears the memory. </p>
<dl class="section return"><dt>Returns</dt><dd>return value of the AEFileReader::closefile() (AEFR_ERR_NOERROR if file was closed successfully; AEFR_ERR_FILE_NOT_OPEN if file isn't open)</dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d0/dab/_a_e_log_parser_8hpp_source.html#l00105">105</a> of file <a class="el" href="../../d0/dab/_a_e_log_parser_8hpp_source.html">AELogParser.hpp</a>.</p>

</div>
</div>
<a id="a04627d27deedd7981a5e106dd8ade5ed" name="a04627d27deedd7981a5e106dd8ade5ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04627d27deedd7981a5e106dd8ade5ed">&#9670;&#160;</a></span>containsSeverity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AELogParser::containsSeverity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/d89/_a_e_typedefs_8hpp.html#adabb025f32e720b44bdd40d4e0784710">cint</a></td>          <td class="paramname"><span class="paramname"><em>severity</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>strictSeverity</em><span class="paramdefsep"> = </span><span class="paramdefval">false</span></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the current log file contains the given severity (or higher, depending on the "strict-severity" flag) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">severity</td><td>The severity to search for</td></tr>
    <tr><td class="paramname">strictSeverity</td><td>The flag to indicate whether the search for severity should be strict (exact)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the log contains the severity, false otherwise; false if the invalid severity was passed or file is closed</dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d0/dab/_a_e_log_parser_8hpp_source.html#l00388">388</a> of file <a class="el" href="../../d0/dab/_a_e_log_parser_8hpp_source.html">AELogParser.hpp</a>.</p>

</div>
</div>
<a id="a997df337f3e8b44e441a804d6b876494" name="a997df337f3e8b44e441a804d6b876494"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a997df337f3e8b44e441a804d6b876494">&#9670;&#160;</a></span>currentEntryCursor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d89/_a_e_typedefs_8hpp.html#a01c88e5c03ebee098af42984516b9aaf">llint</a> AELogParser::currentEntryCursor </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the file cursors of the current valid entry This entry is the one that was read by a previous call to <a class="el" href="#af3c28f50c5f52840be97e631d67b244c" title="Read the next valid entry in the log file of the given severity and module name filter,...">AELogParser::nextEntry()</a> or AELogParser::getNextEntryIndex() </p>
<dl class="section return"><dt>Returns</dt><dd>The file cursors of the current valid entry (in the currently-opened log file); AEFR_ERR_FILE_NOT_OPEN if the file isn't open; AEFR_ERR_READ_EOF if the entry number is invalid (past the end of the log file)</dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d0/dab/_a_e_log_parser_8hpp_source.html#l00203">203</a> of file <a class="el" href="../../d0/dab/_a_e_log_parser_8hpp_source.html">AELogParser.hpp</a>.</p>

</div>
</div>
<a id="a77b12a5ddd2933a8319e523986788292" name="a77b12a5ddd2933a8319e523986788292"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77b12a5ddd2933a8319e523986788292">&#9670;&#160;</a></span>errorFromAELEI()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr <a class="el" href="../../dc/d89/_a_e_typedefs_8hpp.html#adabb025f32e720b44bdd40d4e0784710">cint</a> AELogParser::errorFromAELEI </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../db/d7b/struct_a_e_log_entry_info.html">AELogEntryInfo</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>leInfo</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the error codes from the invalid values in the passed <a class="el" href="../../db/d7b/struct_a_e_log_entry_info.html" title="The struct that holds the information about the log entry, used by AELogParser.">AELogEntryInfo</a> instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">leInfo</td><td>The passed <a class="el" href="../../db/d7b/struct_a_e_log_entry_info.html" title="The struct that holds the information about the log entry, used by AELogParser.">AELogEntryInfo</a> instance to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AELP_ERR_NOERROR if everything is okay; AEFR_ERR_FILE_NOT_OPEN if it's fully invalid; AEFR_ERR_READ_EOF on invalid cursor; AELP_ERR_INVALID_MODULE_NAME on invalid module name; AELP_ERR_INVALID_SEVERITY on invalid type</dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d0/dab/_a_e_log_parser_8hpp_source.html#l00483">483</a> of file <a class="el" href="../../d0/dab/_a_e_log_parser_8hpp_source.html">AELogParser.hpp</a>.</p>

</div>
</div>
<a id="a7c3e2c0736eb6a3ccd84a528d72835ad" name="a7c3e2c0736eb6a3ccd84a528d72835ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c3e2c0736eb6a3ccd84a528d72835ad">&#9670;&#160;</a></span>filterQueue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d89/_a_e_typedefs_8hpp.html#adabb025f32e720b44bdd40d4e0784710">cint</a> AELogParser::filterQueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/dea/struct_a_e_log_entry.html">AELogEntry</a> *&amp;</td>          <td class="paramname"><span class="paramname"><em>ptr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dc/d89/_a_e_typedefs_8hpp.html#adabb025f32e720b44bdd40d4e0784710">cint</a></td>          <td class="paramname"><span class="paramname"><em>severity</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>strictSeverity</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string_view</td>          <td class="paramname"><span class="paramname"><em>mname</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>reallocQueue</em><span class="paramdefsep"> = </span><span class="paramdefval">true</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Filters the passed queue according to the given severity and modulename filters. </p>
<dl class="section warning"><dt>Warning</dt><dd>Make sure the queue is not circled (the "next node" pointer of the last entry in the queue is nullptr). Otherwise this will result in an infinite loop in the function </dd></dl>
<dl class="todo"><dt><b><a class="el" href="../../dd/da0/todo.html#_todo000013">Todo</a></b></dt><dd>Implement a container for the queue to prevent this from happening </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The pointer to the existing queue</td></tr>
    <tr><td class="paramname">severity</td><td>The lowest severity of the log to filter for</td></tr>
    <tr><td class="paramname">strictSeverity</td><td>The flag to indicate whether the filtering for severity should be strict (exact)</td></tr>
    <tr><td class="paramname">mname</td><td>The module name of the log entry to filter for</td></tr>
    <tr><td class="paramname">reallocQueue</td><td>Flag to reallocate the filtered queue (reduces the final memory usage)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Use reallocQueue flag only if the queue was allocated on the heap (like with <a class="el" href="#a182d51b4aa5771e2e6f6919300e571ca" title="Same as the AELogParser::nextEntry() but on massive scale â€“ scans the whole log file and parses it to...">AELogParser::logToQueue()</a>. Otherwise (if it's stack-allocated) it will try to delete[] the stack memory <dl class="section return"><dt>Returns</dt><dd>AELP_ERR_NOERROR (0) on success; On invalid arguments: AELP_ERR_INVALID_QUEUE if ptr is nullptr, AELP_ERR_INVALID_FILTER if mname is empty and severity is AELP_SEVERITY_ALL; On filtering results: AELP_ERR_INVALID_SEVERITY if severity wasn't found in the queue (severity was the only filter), AELP_ERR_INVALID_MODULE_NAME if module name wasn't found in the queue(module name was the only filter), AELP_ERR_FILTER_NO_MATCHES if nothing was found with both passed and valid severity and module name filters</dd></dl>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d2/d77/_a_e_log_parser_8cpp_source.html#l00134">134</a> of file <a class="el" href="../../d2/d77/_a_e_log_parser_8cpp_source.html">AELogParser.cpp</a>.</p>

</div>
</div>
<a id="a89fbdf373de904d275768e4eb15432c7" name="a89fbdf373de904d275768e4eb15432c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89fbdf373de904d275768e4eb15432c7">&#9670;&#160;</a></span>filterQueueName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../dc/d89/_a_e_typedefs_8hpp.html#adabb025f32e720b44bdd40d4e0784710">cint</a> AELogParser::filterQueueName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/dea/struct_a_e_log_entry.html">AELogEntry</a> *&amp;</td>          <td class="paramname"><span class="paramname"><em>ptr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string_view</td>          <td class="paramname"><span class="paramname"><em>mname</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>reallocQueue</em><span class="paramdefsep"> = </span><span class="paramdefval">true</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Filters the passed queue according to the given modulename. </p>
<dl class="section warning"><dt>Warning</dt><dd>Make sure the queue is not circled (the "next node" pointer of the last entry in the queue is nullptr). Otherwise this will result in an infinite loop in the function </dd></dl>
<dl class="todo"><dt><b><a class="el" href="../../dd/da0/todo.html#_todo000015">Todo</a></b></dt><dd>Implement a container for the queue to prevent this from happening </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The pointer to the existing queue</td></tr>
    <tr><td class="paramname">mname</td><td>The module name of the log entry to filter for</td></tr>
    <tr><td class="paramname">reallocQueue</td><td>Flag to reallocate the filtered queue (reduces the final memory usage)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Use reallocQueue flag only if the queue was allocated on the heap (like with <a class="el" href="#a182d51b4aa5771e2e6f6919300e571ca" title="Same as the AELogParser::nextEntry() but on massive scale â€“ scans the whole log file and parses it to...">AELogParser::logToQueue()</a>. Otherwise (if it's stack-allocated) it will try to delete[] the stack memory <dl class="section return"><dt>Returns</dt><dd>Same values as <a class="el" href="#a7c3e2c0736eb6a3ccd84a528d72835ad" title="Filters the passed queue according to the given severity and modulename filters.">AELogParser::filterQueue()</a> but only relating to the module name filter</dd></dl>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d0/dab/_a_e_log_parser_8hpp_source.html#l00327">327</a> of file <a class="el" href="../../d0/dab/_a_e_log_parser_8hpp_source.html">AELogParser.hpp</a>.</p>

</div>
</div>
<a id="ae8545d9e179171cd0ea6cf462c755715" name="ae8545d9e179171cd0ea6cf462c755715"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8545d9e179171cd0ea6cf462c755715">&#9670;&#160;</a></span>filterQueueType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../dc/d89/_a_e_typedefs_8hpp.html#adabb025f32e720b44bdd40d4e0784710">cint</a> AELogParser::filterQueueType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/dea/struct_a_e_log_entry.html">AELogEntry</a> *&amp;</td>          <td class="paramname"><span class="paramname"><em>ptr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dc/d89/_a_e_typedefs_8hpp.html#adabb025f32e720b44bdd40d4e0784710">cint</a></td>          <td class="paramname"><span class="paramname"><em>severity</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>strictSeverity</em><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>reallocQueue</em><span class="paramdefsep"> = </span><span class="paramdefval">true</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Filters the passed queue according to the given severity. </p>
<dl class="section warning"><dt>Warning</dt><dd>Make sure the queue is not circled (the "next node" pointer of the last entry in the queue is nullptr). Otherwise this will result in an infinite loop in the function </dd></dl>
<dl class="todo"><dt><b><a class="el" href="../../dd/da0/todo.html#_todo000014">Todo</a></b></dt><dd>Implement a container for the queue to prevent this from happening </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The pointer to the existing queue</td></tr>
    <tr><td class="paramname">severity</td><td>The lowest severity of the log to filter for</td></tr>
    <tr><td class="paramname">strictSeverity</td><td>The flag to indicate whether the filtering for severity should be strict (exact)</td></tr>
    <tr><td class="paramname">reallocQueue</td><td>Flag to reallocate the filtered queue (reduces the final memory usage)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Use reallocQueue flag only if the queue was allocated on the heap (like with <a class="el" href="#a182d51b4aa5771e2e6f6919300e571ca" title="Same as the AELogParser::nextEntry() but on massive scale â€“ scans the whole log file and parses it to...">AELogParser::logToQueue()</a>. Otherwise (if it's stack-allocated) it will try to delete[] the stack memory <dl class="section return"><dt>Returns</dt><dd>Same values as <a class="el" href="#a7c3e2c0736eb6a3ccd84a528d72835ad" title="Filters the passed queue according to the given severity and modulename filters.">AELogParser::filterQueue()</a> but only relating to the severity filter</dd></dl>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d0/dab/_a_e_log_parser_8hpp_source.html#l00313">313</a> of file <a class="el" href="../../d0/dab/_a_e_log_parser_8hpp_source.html">AELogParser.hpp</a>.</p>

</div>
</div>
<a id="afcff7caee18bdcafa1dc0edb75a75590" name="afcff7caee18bdcafa1dc0edb75a75590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcff7caee18bdcafa1dc0edb75a75590">&#9670;&#160;</a></span>findNextEntry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/d7b/struct_a_e_log_entry_info.html">AELogEntryInfo</a> AELogParser::findNextEntry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/d89/_a_e_typedefs_8hpp.html#adabb025f32e720b44bdd40d4e0784710">cint</a></td>          <td class="paramname"><span class="paramname"><em>severity</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string_view</td>          <td class="paramname"><span class="paramname"><em>mname</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>strictSeverity</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the <a class="el" href="../../db/d7b/struct_a_e_log_entry_info.html" title="The struct that holds the information about the log entry, used by AELogParser.">AELogEntryInfo</a> corresponding to the next log entry with the specified severity and module name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">severity</td><td>The severity of the log entry to look for</td></tr>
    <tr><td class="paramname">mname</td><td>The module name of the log entry to search for</td></tr>
    <tr><td class="paramname">strictSeverity</td><td>The flag to indicate whether the search for severity should be strict (exact)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="../../db/d7b/struct_a_e_log_entry_info.html" title="The struct that holds the information about the log entry, used by AELogParser.">AELogEntryInfo</a> instance that corresponds to that log entry</dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d2/d77/_a_e_log_parser_8cpp_source.html#l00206">206</a> of file <a class="el" href="../../d2/d77/_a_e_log_parser_8cpp_source.html">AELogParser.cpp</a>.</p>

</div>
</div>
<a id="a6ba4173940c2f7a0bcad84032309e453" name="a6ba4173940c2f7a0bcad84032309e453"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ba4173940c2f7a0bcad84032309e453">&#9670;&#160;</a></span>getCurrentEntryIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t AELogParser::getCurrentEntryIndex </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the order number (index) of the current log entry (that was attempted to be read) </p>
<dl class="section return"><dt>Returns</dt><dd>The index of the current entry as std::size_t</dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d0/dab/_a_e_log_parser_8hpp_source.html#l00215">215</a> of file <a class="el" href="../../d0/dab/_a_e_log_parser_8hpp_source.html">AELogParser.hpp</a>.</p>

</div>
</div>
<a id="a3698cc59ff476cb2b5423cd5a54062ff" name="a3698cc59ff476cb2b5423cd5a54062ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3698cc59ff476cb2b5423cd5a54062ff">&#9670;&#160;</a></span>getEntryCursorAll()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="../../db/d7b/struct_a_e_log_entry_info.html">AELogEntryInfo</a> &gt; AELogParser::getEntryCursorAll </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the list of file cursors of the valid entries, separated by type. </p>
<dl class="section note"><dt>Note</dt><dd>If the file is not open, the returned vector is empty</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>(by value) The vector of <a class="el" href="../../db/d7b/struct_a_e_log_entry_info.html" title="The struct that holds the information about the log entry, used by AELogParser.">AELogEntryInfo</a>, each having the (cursor) index, index of the module name, and type of each valid entry</dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d0/dab/_a_e_log_parser_8hpp_source.html#l00236">236</a> of file <a class="el" href="../../d0/dab/_a_e_log_parser_8hpp_source.html">AELogParser.hpp</a>.</p>

</div>
</div>
<a id="a63a04021dcd2c31540c50182f8912c9d" name="a63a04021dcd2c31540c50182f8912c9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63a04021dcd2c31540c50182f8912c9d">&#9670;&#160;</a></span>getFileName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string AELogParser::getFileName </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the name of the opened file, devoid of the path. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../dd/dd5/class_a_e_file_reader.html#a753c6f40c4a15739ed88aa0937f72969" title="Returns the name of the opened file, devoid of the path.">AEFileReader::getFileName()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>std::string of the opened file name; emtpy string otherwise</dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d0/dab/_a_e_log_parser_8hpp_source.html#l00444">444</a> of file <a class="el" href="../../d0/dab/_a_e_log_parser_8hpp_source.html">AELogParser.hpp</a>.</p>

</div>
</div>
<a id="a44ec617b1dfe73f33a25a72172e69a95" name="a44ec617b1dfe73f33a25a72172e69a95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44ec617b1dfe73f33a25a72172e69a95">&#9670;&#160;</a></span>getFileReader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dd/dd5/class_a_e_file_reader.html">AEFileReader</a> &amp; AELogParser::getFileReader </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the reference to the <a class="el" href="../../dd/dd5/class_a_e_file_reader.html" title="ArtyK&#39;s Engine File Reader; umm, it reads data from the given file.">AEFileReader</a> object of this instance of <a class="el" href="../../d8/d52/class_a_e_log_parser.html" title="ArtyK&#39;s Engine&#39;s Log Parser; it parses the log files that AELogger writes.">AELogParser</a>. </p>
<dl class="section warning"><dt>Warning</dt><dd>Be carefull with it</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the reference to the <a class="el" href="../../dd/dd5/class_a_e_file_reader.html" title="ArtyK&#39;s Engine File Reader; umm, it reads data from the given file.">AEFileReader</a> object</dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d0/dab/_a_e_log_parser_8hpp_source.html#l00462">462</a> of file <a class="el" href="../../d0/dab/_a_e_log_parser_8hpp_source.html">AELogParser.hpp</a>.</p>

</div>
</div>
<a id="a6408e9d9b209c88d32d340a76160c12e" name="a6408e9d9b209c88d32d340a76160c12e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6408e9d9b209c88d32d340a76160c12e">&#9670;&#160;</a></span>getFullFileName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string AELogParser::getFullFileName </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the full name of currently open file, including the relative path, if such was provided. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../dd/dd5/class_a_e_file_reader.html#aacd2c57289ebfe1f9549a3ce13067d2c" title="Returns the full name of currently open file, including the relative path, if such was provided.">AEFileReader::getFullFileName()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>std::string of the opened file (including relative path if was given); empty string otherwise</dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d0/dab/_a_e_log_parser_8hpp_source.html#l00426">426</a> of file <a class="el" href="../../d0/dab/_a_e_log_parser_8hpp_source.html">AELogParser.hpp</a>.</p>

</div>
</div>
<a id="a8b852e7f006c6414580aaec49dab321a" name="a8b852e7f006c6414580aaec49dab321a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b852e7f006c6414580aaec49dab321a">&#9670;&#160;</a></span>getFullPath()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string AELogParser::getFullPath </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the full, absolute path of the opened file. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../dd/dd5/class_a_e_file_reader.html#ad762205dbc9d1c3f2e2043bf8aeebf7c" title="Returns the full, absolute path of the opened file.">AEFileReader::getFullPath()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>std::string of the absolute path of the opened file; empty string otherwise</dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d0/dab/_a_e_log_parser_8hpp_source.html#l00453">453</a> of file <a class="el" href="../../d0/dab/_a_e_log_parser_8hpp_source.html">AELogParser.hpp</a>.</p>

</div>
</div>
<a id="a09e70214699c5ab9b26a68dec456ad3b" name="a09e70214699c5ab9b26a68dec456ad3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09e70214699c5ab9b26a68dec456ad3b">&#9670;&#160;</a></span>getInvalidEntryCursorAll()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="../../dc/d89/_a_e_typedefs_8hpp.html#a01c88e5c03ebee098af42984516b9aaf">llint</a> &gt; AELogParser::getInvalidEntryCursorAll </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the list of file cursors of the invalid entries. </p>
<p>In the return vector, llint is the index of the cursor in the file </p><dl class="section note"><dt>Note</dt><dd>If the file is not open, the returned vector is empty</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>(by value) The vector of llint's, having the cursor indices for each invalid entry</dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d0/dab/_a_e_log_parser_8hpp_source.html#l00246">246</a> of file <a class="el" href="../../d0/dab/_a_e_log_parser_8hpp_source.html">AELogParser.hpp</a>.</p>

</div>
</div>
<a id="ab3257ef44350e547976d6199ffdb743f" name="ab3257ef44350e547976d6199ffdb743f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3257ef44350e547976d6199ffdb743f">&#9670;&#160;</a></span>getModuleAmount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../dc/d89/_a_e_typedefs_8hpp.html#a689c96cb00098d457d55842c96cc71eb">ullint</a> <a class="el" href="../../d0/d8a/class_____a_e_module_base.html">__AEModuleBase</a>&lt; <a class="el" href="../../d8/d52/class_a_e_log_parser.html">AELogParser</a>  &gt;::getModuleAmount </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the amount of instances of the module currently existing. </p>
<dl class="section return"><dt>Returns</dt><dd>Unsigned long long of the module amount</dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d7/d7f/_a_e_module_base_8hpp_source.html#l00091">91</a> of file <a class="el" href="../../d7/d7f/_a_e_module_base_8hpp_source.html">AEModuleBase.hpp</a>.</p>

</div>
</div>
<a id="a2f3461ab9cf4aa231ba93ce28f7f856c" name="a2f3461ab9cf4aa231ba93ce28f7f856c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f3461ab9cf4aa231ba93ce28f7f856c">&#9670;&#160;</a></span>getModuleName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr std::string_view <a class="el" href="../../d0/d8a/class_____a_e_module_base.html">__AEModuleBase</a>&lt; <a class="el" href="../../d8/d52/class_a_e_log_parser.html">AELogParser</a>  &gt;::getModuleName </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the name of the registered module. </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a0a1f374dbcebcbe44497d593247ac8c6" name="a0a1f374dbcebcbe44497d593247ac8c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a1f374dbcebcbe44497d593247ac8c6">&#9670;&#160;</a></span>getRelativePath()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string AELogParser::getRelativePath </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the relative path of the opened file. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../dd/dd5/class_a_e_file_reader.html#aa1f9d6a22bac28f3409558084eb03103" title="Returns the relative path of the opened file.">AEFileReader::getRelativePath()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>std::string of the relative file path of opened file; empty string otherwise</dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d0/dab/_a_e_log_parser_8hpp_source.html#l00435">435</a> of file <a class="el" href="../../d0/dab/_a_e_log_parser_8hpp_source.html">AELogParser.hpp</a>.</p>

</div>
</div>
<a id="af349b880be4cdd8c6d27960a038680ab" name="af349b880be4cdd8c6d27960a038680ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af349b880be4cdd8c6d27960a038680ab">&#9670;&#160;</a></span>isClosed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AELogParser::isClosed </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the file is closed by the <a class="el" href="../../d8/d52/class_a_e_log_parser.html" title="ArtyK&#39;s Engine&#39;s Log Parser; it parses the log files that AELogger writes.">AELogParser</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../dd/dd5/class_a_e_file_reader.html#a81bb672d7d1a142c7473d880a3842073" title="Checks if a file isn&#39;t open by this file-reader.">AEFileReader::isClosed()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true is file is closed (no file opened), false otherwise</dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d0/dab/_a_e_log_parser_8hpp_source.html#l00417">417</a> of file <a class="el" href="../../d0/dab/_a_e_log_parser_8hpp_source.html">AELogParser.hpp</a>.</p>

</div>
</div>
<a id="a318c93562f4b8d14aff66a63998bf157" name="a318c93562f4b8d14aff66a63998bf157"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a318c93562f4b8d14aff66a63998bf157">&#9670;&#160;</a></span>isOpen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AELogParser::isOpen </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the file is opened by the <a class="el" href="../../d8/d52/class_a_e_log_parser.html" title="ArtyK&#39;s Engine&#39;s Log Parser; it parses the log files that AELogger writes.">AELogParser</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../dd/dd5/class_a_e_file_reader.html#a07f32763fbb1df143c8aab2be7b856c1" title="Checks if a file is open by this file-reader.">AEFileReader::isOpen()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true if file is opened, false otherwise</dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d0/dab/_a_e_log_parser_8hpp_source.html#l00408">408</a> of file <a class="el" href="../../d0/dab/_a_e_log_parser_8hpp_source.html">AELogParser.hpp</a>.</p>

</div>
</div>
<a id="a182d51b4aa5771e2e6f6919300e571ca" name="a182d51b4aa5771e2e6f6919300e571ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a182d51b4aa5771e2e6f6919300e571ca">&#9670;&#160;</a></span>logToQueue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d89/_a_e_typedefs_8hpp.html#adabb025f32e720b44bdd40d4e0784710">cint</a> AELogParser::logToQueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/dea/struct_a_e_log_entry.html">AELogEntry</a> *&amp;</td>          <td class="paramname"><span class="paramname"><em>begin</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dc/d89/_a_e_typedefs_8hpp.html#adabb025f32e720b44bdd40d4e0784710">cint</a></td>          <td class="paramname"><span class="paramname"><em>severity</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="../../dc/dd8/_a_e_log_types_8hpp.html#a5a4597f7fb7f605706194f7b98d683e6">AELOG_TYPE_DEBUG</a></span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>strictSeverity</em><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string_view</td>          <td class="paramname"><span class="paramname"><em>mname</em><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as the <a class="el" href="#af3c28f50c5f52840be97e631d67b244c" title="Read the next valid entry in the log file of the given severity and module name filter,...">AELogParser::nextEntry()</a> but on massive scale &ndash; scans the whole log file and parses it to the freshly-allocated queue. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../da/dea/struct_a_e_log_entry.html#a42447b345f72f22ec655556af2db7c28" title="Allocates the queue of the given size on the heap and returns the pointer to it&#39;s first node.">AELogEntry::makeQueue()</a> The parsed queue is filtered with the given severity level and "strict severity search" flag </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If this queue isn't deallocated (deleted) before dropping the queue pointer, this <b>WILL</b> lead to memory leaks!</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>The pointer to which the queue will be allocated</td></tr>
    <tr><td class="paramname">severity</td><td>The lowest severity of the log to find</td></tr>
    <tr><td class="paramname">strictSeverity</td><td>The flag to indicate whether the search for severity should be strict (exact)</td></tr>
    <tr><td class="paramname">mname</td><td>The module name of the log entry to search for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AELP_ERR_NOERROR (0) on success; or AEFR_ERR_* (-1 to -8) or AELE_ERR_* (-11 to -15), AELP_ERR_*(-20 to -24) flags on error </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d2/d77/_a_e_log_parser_8cpp_source.html#l00107">107</a> of file <a class="el" href="../../d2/d77/_a_e_log_parser_8cpp_source.html">AELogParser.cpp</a>.</p>

</div>
</div>
<a id="ae5044cf01623156d91ddc74492b0aeda" name="ae5044cf01623156d91ddc74492b0aeda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5044cf01623156d91ddc74492b0aeda">&#9670;&#160;</a></span>logToQueueName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d89/_a_e_typedefs_8hpp.html#adabb025f32e720b44bdd40d4e0784710">cint</a> AELogParser::logToQueueName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/dea/struct_a_e_log_entry.html">AELogEntry</a> *&amp;</td>          <td class="paramname"><span class="paramname"><em>begin</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string_view</td>          <td class="paramname"><span class="paramname"><em>mname</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A shortcut to <a class="el" href="#a182d51b4aa5771e2e6f6919300e571ca" title="Same as the AELogParser::nextEntry() but on massive scale â€“ scans the whole log file and parses it to...">AELogParser::logToQueue()</a> to filter only by the module name of the log entries. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a182d51b4aa5771e2e6f6919300e571ca" title="Same as the AELogParser::nextEntry() but on massive scale â€“ scans the whole log file and parses it to...">AELogParser::logToQueue()</a> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If this queue isn't deallocated (deleted) before dropping the queue pointer, this <b>WILL</b> lead to memory leaks!</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>The pointer to which the queue will be allocated</td></tr>
    <tr><td class="paramname">mname</td><td>The module name of the log entry to search for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AELP_ERR_NOERROR (0) on success; or AEFR_ERR_* (-1 to -8) or AELE_ERR_* (-11 to -15), AELP_ERR_*(-20 to -24) flags on error </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d0/dab/_a_e_log_parser_8hpp_source.html#l00284">284</a> of file <a class="el" href="../../d0/dab/_a_e_log_parser_8hpp_source.html">AELogParser.hpp</a>.</p>

</div>
</div>
<a id="ab84bb93f08ed48082f74b00290deb308" name="ab84bb93f08ed48082f74b00290deb308"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab84bb93f08ed48082f74b00290deb308">&#9670;&#160;</a></span>logToQueueType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d89/_a_e_typedefs_8hpp.html#adabb025f32e720b44bdd40d4e0784710">cint</a> AELogParser::logToQueueType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/dea/struct_a_e_log_entry.html">AELogEntry</a> *&amp;</td>          <td class="paramname"><span class="paramname"><em>begin</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dc/d89/_a_e_typedefs_8hpp.html#adabb025f32e720b44bdd40d4e0784710">cint</a></td>          <td class="paramname"><span class="paramname"><em>severity</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>strictSeverity</em><span class="paramdefsep"> = </span><span class="paramdefval">false</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A shortcut to <a class="el" href="#a182d51b4aa5771e2e6f6919300e571ca" title="Same as the AELogParser::nextEntry() but on massive scale â€“ scans the whole log file and parses it to...">AELogParser::logToQueue()</a> to filter only by type/severity of the log entries. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a182d51b4aa5771e2e6f6919300e571ca" title="Same as the AELogParser::nextEntry() but on massive scale â€“ scans the whole log file and parses it to...">AELogParser::logToQueue()</a> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If this queue isn't deallocated (deleted) before dropping the queue pointer, this <b>WILL</b> lead to memory leaks!</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>The pointer to which the queue will be allocated</td></tr>
    <tr><td class="paramname">severity</td><td>The lowest severity of the log to find</td></tr>
    <tr><td class="paramname">strictSeverity</td><td>The flag to indicate whether the search for severity should be strict (exact)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AELP_ERR_NOERROR (0) on success; or AEFR_ERR_* (-1 to -8) or AELE_ERR_* (-11 to -15), AELP_ERR_*(-20 to -24) flags on error </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d0/dab/_a_e_log_parser_8hpp_source.html#l00272">272</a> of file <a class="el" href="../../d0/dab/_a_e_log_parser_8hpp_source.html">AELogParser.hpp</a>.</p>

</div>
</div>
<a id="af3c28f50c5f52840be97e631d67b244c" name="af3c28f50c5f52840be97e631d67b244c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3c28f50c5f52840be97e631d67b244c">&#9670;&#160;</a></span>nextEntry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d89/_a_e_typedefs_8hpp.html#adabb025f32e720b44bdd40d4e0784710">cint</a> AELogParser::nextEntry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/dea/struct_a_e_log_entry.html">AELogEntry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>entry</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dc/d89/_a_e_typedefs_8hpp.html#adabb025f32e720b44bdd40d4e0784710">cint</a></td>          <td class="paramname"><span class="paramname"><em>severity</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="../../dc/dd8/_a_e_log_types_8hpp.html#a5a4597f7fb7f605706194f7b98d683e6">AELOG_TYPE_DEBUG</a></span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>strictSeverity</em><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string_view</td>          <td class="paramname"><span class="paramname"><em>mname</em><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the next <em>valid</em> entry in the log file of the given severity and module name filter, and parse it to the given <a class="el" href="../../da/dea/struct_a_e_log_entry.html" title="The structure for the data of the log entry to be manipulated with the log files.">AELogEntry</a> object. </p>
<dl class="section note"><dt>Note</dt><dd>If the strictSeverity is false, then the severity value just changes the lowest limit of the log severity. Otherwise it sets the exact severity to look for </dd>
<dd>
The module name filter is applied after the severity filter. </dd>
<dd>
AELOG_TYPE_INVALID works the same as AELOG_TYPE_DEBUG. This function parses only <em>valid</em> entries.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>The log entry object to parse things into</td></tr>
    <tr><td class="paramname">severity</td><td>The severity of the log entry to look for</td></tr>
    <tr><td class="paramname">strictSeverity</td><td>The flag to indicate whether the search for severity should be strict (exact)</td></tr>
    <tr><td class="paramname">mname</td><td>The module name of the log entry to search for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AELP_ERR_NOERROR (0) on success, or AEFR_ERR_* (-1 to -8) or AELE_ERR_* (-11 to -15) flags on error; error codes from <a class="el" href="#a77b12a5ddd2933a8319e523986788292" title="Determines the error codes from the invalid values in the passed AELogEntryInfo instance.">AELogParser::errorFromAELEI()</a></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a77b12a5ddd2933a8319e523986788292" title="Determines the error codes from the invalid values in the passed AELogEntryInfo instance.">AELogParser::errorFromAELEI()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d2/d77/_a_e_log_parser_8cpp_source.html#l00075">75</a> of file <a class="el" href="../../d2/d77/_a_e_log_parser_8cpp_source.html">AELogParser.cpp</a>.</p>

</div>
</div>
<a id="ae89b754ad98409469e9b7405f63edee2" name="ae89b754ad98409469e9b7405f63edee2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae89b754ad98409469e9b7405f63edee2">&#9670;&#160;</a></span>nextEntryCursor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d89/_a_e_typedefs_8hpp.html#a01c88e5c03ebee098af42984516b9aaf">llint</a> AELogParser::nextEntryCursor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/d89/_a_e_typedefs_8hpp.html#adabb025f32e720b44bdd40d4e0784710">cint</a></td>          <td class="paramname"><span class="paramname"><em>severity</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="../../dc/dd8/_a_e_log_types_8hpp.html#a5a4597f7fb7f605706194f7b98d683e6">AELOG_TYPE_DEBUG</a></span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>strictSeverity</em><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string_view</td>          <td class="paramname"><span class="paramname"><em>mname</em><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the next indexed <em>valid</em> log entry in the file of the given severity and module name filter, and return it's file cursors in the file. </p>
<dl class="section note"><dt>Note</dt><dd>The severity value just changes the lowest limit of the log severity (lowest by default is debug). If a higher severity is encountered, it's read as well. </dd>
<dd>
AELOG_TYPE_INVALID works the same as AELOG_TYPE_DEBUG. This function parses only <em>valid</em> entries.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">severity</td><td>The lowest severity of the log to find</td></tr>
    <tr><td class="paramname">strictSeverity</td><td>The flag to indicate whether the search for severity should be strict (exact)</td></tr>
    <tr><td class="paramname">mname</td><td>The module name of the log entry to search for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The file cursors of the next valid entry (in the currently-opened log file); error codes from <a class="el" href="#a77b12a5ddd2933a8319e523986788292" title="Determines the error codes from the invalid values in the passed AELogEntryInfo instance.">AELogParser::errorFromAELEI()</a></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a77b12a5ddd2933a8319e523986788292" title="Determines the error codes from the invalid values in the passed AELogEntryInfo instance.">AELogParser::errorFromAELEI()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d0/dab/_a_e_log_parser_8hpp_source.html#l00167">167</a> of file <a class="el" href="../../d0/dab/_a_e_log_parser_8hpp_source.html">AELogParser.hpp</a>.</p>

</div>
</div>
<a id="a6e74863a220efa6ca9c3b3067d953469" name="a6e74863a220efa6ca9c3b3067d953469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e74863a220efa6ca9c3b3067d953469">&#9670;&#160;</a></span>nextEntryCursorName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d89/_a_e_typedefs_8hpp.html#a01c88e5c03ebee098af42984516b9aaf">llint</a> AELogParser::nextEntryCursorName </td>
          <td>(</td>
          <td class="paramtype">const std::string_view</td>          <td class="paramname"><span class="paramname"><em>mname</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the next indexed <em>valid</em> log entry in the file of the given module name filter, and return it's file cursors in the file. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ae89b754ad98409469e9b7405f63edee2" title="Read the next indexed valid log entry in the file of the given severity and module name filter,...">AELogParser::nextEntryCursor()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mname</td><td>The module name of the log entry to search for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The file cursors of the next valid entry (in the currently-opened log file); error codes from <a class="el" href="#a77b12a5ddd2933a8319e523986788292" title="Determines the error codes from the invalid values in the passed AELogEntryInfo instance.">AELogParser::errorFromAELEI()</a></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a77b12a5ddd2933a8319e523986788292" title="Determines the error codes from the invalid values in the passed AELogEntryInfo instance.">AELogParser::errorFromAELEI()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d0/dab/_a_e_log_parser_8hpp_source.html#l00185">185</a> of file <a class="el" href="../../d0/dab/_a_e_log_parser_8hpp_source.html">AELogParser.hpp</a>.</p>

</div>
</div>
<a id="aff3bcd025e52cd530cbb576d47915c53" name="aff3bcd025e52cd530cbb576d47915c53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff3bcd025e52cd530cbb576d47915c53">&#9670;&#160;</a></span>nextEntryCursorType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d89/_a_e_typedefs_8hpp.html#a01c88e5c03ebee098af42984516b9aaf">llint</a> AELogParser::nextEntryCursorType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/d89/_a_e_typedefs_8hpp.html#adabb025f32e720b44bdd40d4e0784710">cint</a></td>          <td class="paramname"><span class="paramname"><em>severity</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>strictSeverity</em><span class="paramdefsep"> = </span><span class="paramdefval">false</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the next indexed <em>valid</em> log entry in the file of the given severity filter and return it's file cursors in the file. </p>
<dl class="section note"><dt>Note</dt><dd>AELOG_TYPE_INVALID works the same as AELOG_TYPE_DEBUG. This function parses only <em>valid</em> entries. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ae89b754ad98409469e9b7405f63edee2" title="Read the next indexed valid log entry in the file of the given severity and module name filter,...">AELogParser::nextEntryCursor()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">severity</td><td>The lowest severity of the log to find</td></tr>
    <tr><td class="paramname">strictSeverity</td><td>The flag to indicate whether the search for severity should be strict (exact)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The file cursors of the next valid entry (in the currently-opened log file); error codes from <a class="el" href="#a77b12a5ddd2933a8319e523986788292" title="Determines the error codes from the invalid values in the passed AELogEntryInfo instance.">AELogParser::errorFromAELEI()</a></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a77b12a5ddd2933a8319e523986788292" title="Determines the error codes from the invalid values in the passed AELogEntryInfo instance.">AELogParser::errorFromAELEI()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d0/dab/_a_e_log_parser_8hpp_source.html#l00196">196</a> of file <a class="el" href="../../d0/dab/_a_e_log_parser_8hpp_source.html">AELogParser.hpp</a>.</p>

</div>
</div>
<a id="a768d4b94cbf1504d72f93ec5d131e915" name="a768d4b94cbf1504d72f93ec5d131e915"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a768d4b94cbf1504d72f93ec5d131e915">&#9670;&#160;</a></span>nextEntryName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d89/_a_e_typedefs_8hpp.html#adabb025f32e720b44bdd40d4e0784710">cint</a> AELogParser::nextEntryName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/dea/struct_a_e_log_entry.html">AELogEntry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>entry</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string_view</td>          <td class="paramname"><span class="paramname"><em>mname</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the next <em>valid</em> entry in the log file of the given module name, and parse it into the given <a class="el" href="../../da/dea/struct_a_e_log_entry.html" title="The structure for the data of the log entry to be manipulated with the log files.">AELogEntry</a> object. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#af3c28f50c5f52840be97e631d67b244c" title="Read the next valid entry in the log file of the given severity and module name filter,...">AELogParser::nextEntry()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>The log entry object to parse things into</td></tr>
    <tr><td class="paramname">mname</td><td>The module name of the log entry to search for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AELP_ERR_NOERROR (0) on success, or AEFR_ERR_* (-1 to -8) or AELE_ERR_* (-11 to -15) flags on error; error codes from <a class="el" href="#a77b12a5ddd2933a8319e523986788292" title="Determines the error codes from the invalid values in the passed AELogEntryInfo instance.">AELogParser::errorFromAELEI()</a></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a77b12a5ddd2933a8319e523986788292" title="Determines the error codes from the invalid values in the passed AELogEntryInfo instance.">AELogParser::errorFromAELEI()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d0/dab/_a_e_log_parser_8hpp_source.html#l00142">142</a> of file <a class="el" href="../../d0/dab/_a_e_log_parser_8hpp_source.html">AELogParser.hpp</a>.</p>

</div>
</div>
<a id="a0e03f67c2a0eaa0317904a2bd9f70cc0" name="a0e03f67c2a0eaa0317904a2bd9f70cc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e03f67c2a0eaa0317904a2bd9f70cc0">&#9670;&#160;</a></span>nextEntryType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d89/_a_e_typedefs_8hpp.html#adabb025f32e720b44bdd40d4e0784710">cint</a> AELogParser::nextEntryType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/dea/struct_a_e_log_entry.html">AELogEntry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>entry</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dc/d89/_a_e_typedefs_8hpp.html#adabb025f32e720b44bdd40d4e0784710">cint</a></td>          <td class="paramname"><span class="paramname"><em>severity</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>strictSeverity</em><span class="paramdefsep"> = </span><span class="paramdefval">false</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the next <em>valid</em> entry in the log file of the given severity, and parse it to the given <a class="el" href="../../da/dea/struct_a_e_log_entry.html" title="The structure for the data of the log entry to be manipulated with the log files.">AELogEntry</a> object. </p>
<dl class="section see"><dt>See also</dt><dd>AELogEntry::nextEntry()</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>The log entry object to parse things into</td></tr>
    <tr><td class="paramname">severity</td><td>The lowest limit of severity of the log entry to look for</td></tr>
    <tr><td class="paramname">strictSeverity</td><td>The flag to indicate whether the search for severity should be strict (exact)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AELP_ERR_NOERROR (0) on success, or AEFR_ERR_* (-1 to -8) or AELE_ERR_* (-11 to -15) flags on error; error codes from <a class="el" href="#a77b12a5ddd2933a8319e523986788292" title="Determines the error codes from the invalid values in the passed AELogEntryInfo instance.">AELogParser::errorFromAELEI()</a></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a77b12a5ddd2933a8319e523986788292" title="Determines the error codes from the invalid values in the passed AELogEntryInfo instance.">AELogParser::errorFromAELEI()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d0/dab/_a_e_log_parser_8hpp_source.html#l00153">153</a> of file <a class="el" href="../../d0/dab/_a_e_log_parser_8hpp_source.html">AELogParser.hpp</a>.</p>

</div>
</div>
<a id="a8e90913ac25c938e2e84a9887c5bae66" name="a8e90913ac25c938e2e84a9887c5bae66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e90913ac25c938e2e84a9887c5bae66">&#9670;&#160;</a></span>openLog()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d89/_a_e_typedefs_8hpp.html#adabb025f32e720b44bdd40d4e0784710">cint</a> AELogParser::openLog </td>
          <td>(</td>
          <td class="paramtype">const std::string_view</td>          <td class="paramname"><span class="paramname"><em>fname</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opens the log file, reading and parsing every single entry, classifying it by type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fname</td><td>The name of the file to open</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AELP_ERR_NOERROR (0) on success, or AEFR_ERR_* (-1 to -8) or AELE_ERR_* (-11 to -15) flags on error</dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d2/d77/_a_e_log_parser_8cpp_source.html#l00011">11</a> of file <a class="el" href="../../d2/d77/_a_e_log_parser_8cpp_source.html">AELogParser.cpp</a>.</p>

</div>
</div>
<a id="abfe665d273e635559e15339dd34bace5" name="abfe665d273e635559e15339dd34bace5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfe665d273e635559e15339dd34bace5">&#9670;&#160;</a></span>REGISTER_MODULE()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">AELogParser::REGISTER_MODULE </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d8/d52/class_a_e_log_parser.html">AELogParser</a></td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa4c1d23fe1fb7303afc76c0e5a6c73b4" name="aa4c1d23fe1fb7303afc76c0e5a6c73b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4c1d23fe1fb7303afc76c0e5a6c73b4">&#9670;&#160;</a></span>setNextEntryIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d89/_a_e_typedefs_8hpp.html#adabb025f32e720b44bdd40d4e0784710">cint</a> AELogParser::setNextEntryIndex </td>
          <td>(</td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>entryIndex</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the order number (index) of the next log entry to be parsed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entryIndex</td><td>The order number of the next entry</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AELP_ERR_NOERROR on success; AEFR_ERR_READ_EOF if the value was larger than the (amount of valid parsed entries - 1); AEFR_ERR_FILE_NOT_OPEN if file wasn't open</dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d0/dab/_a_e_log_parser_8hpp_source.html#l00222">222</a> of file <a class="el" href="../../d0/dab/_a_e_log_parser_8hpp_source.html">AELogParser.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a9c7c7db04ea7f316e6c8905d6bb43984" name="a9c7c7db04ea7f316e6c8905d6bb43984"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c7c7db04ea7f316e6c8905d6bb43984">&#9670;&#160;</a></span>m_arrEntryAmount</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;<a class="el" href="../../dc/d89/_a_e_typedefs_8hpp.html#a689c96cb00098d457d55842c96cc71eb">ullint</a>, 9&gt; AELogParser::m_arrEntryAmount</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The amount of log entries read in the file, separated by type/severity. </p>

<p class="definition">Definition at line <a class="el" href="../../d0/dab/_a_e_log_parser_8hpp_source.html#l00552">552</a> of file <a class="el" href="../../d0/dab/_a_e_log_parser_8hpp_source.html">AELogParser.hpp</a>.</p>

</div>
</div>
<a id="a7a38c688d9485750a19f272ceee513fd" name="a7a38c688d9485750a19f272ceee513fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a38c688d9485750a19f272ceee513fd">&#9670;&#160;</a></span>m_frLogReader</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dd/dd5/class_a_e_file_reader.html">AEFileReader</a> AELogParser::m_frLogReader</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The file reader of the opened log file. </p>

<p class="definition">Definition at line <a class="el" href="../../d0/dab/_a_e_log_parser_8hpp_source.html#l00542">542</a> of file <a class="el" href="../../d0/dab/_a_e_log_parser_8hpp_source.html">AELogParser.hpp</a>.</p>

</div>
</div>
<a id="a8013f4b6fa684c9b2346835e1ab1d84f" name="a8013f4b6fa684c9b2346835e1ab1d84f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8013f4b6fa684c9b2346835e1ab1d84f">&#9670;&#160;</a></span>m_mapModuleNames</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt; std::string, std::pair &lt;<a class="el" href="../../dc/d89/_a_e_typedefs_8hpp.html#a689c96cb00098d457d55842c96cc71eb">ullint</a>, short&gt; &gt; AELogParser::m_mapModuleNames</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The map of the all module names parsed in the log file. </p>

<p class="definition">Definition at line <a class="el" href="../../d0/dab/_a_e_log_parser_8hpp_source.html#l00550">550</a> of file <a class="el" href="../../d0/dab/_a_e_log_parser_8hpp_source.html">AELogParser.hpp</a>.</p>

</div>
</div>
<a id="a61389d7cbc5253a1ee578d8be67ea078" name="a61389d7cbc5253a1ee578d8be67ea078"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61389d7cbc5253a1ee578d8be67ea078">&#9670;&#160;</a></span>m_ullCurrentEntry</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::atomic&lt;std::size_t&gt; AELogParser::m_ullCurrentEntry</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number corresponding to the currently-read <em>valid</em> entry in the log file. </p>
<p>The maximum value corresponds to the size of m_vecEntryIndices </p>

<p class="definition">Definition at line <a class="el" href="../../d0/dab/_a_e_log_parser_8hpp_source.html#l00555">555</a> of file <a class="el" href="../../d0/dab/_a_e_log_parser_8hpp_source.html">AELogParser.hpp</a>.</p>

</div>
</div>
<a id="aa6b53ab9e5c623900a03d4ea16eb5a99" name="aa6b53ab9e5c623900a03d4ea16eb5a99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6b53ab9e5c623900a03d4ea16eb5a99">&#9670;&#160;</a></span>m_ullModulesAlive</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::atomic&lt;std::size_t&gt; <a class="el" href="../../d0/d8a/class_____a_e_module_base.html">__AEModuleBase</a>&lt; <a class="el" href="../../d8/d52/class_a_e_log_parser.html">AELogParser</a>  &gt;::m_ullModulesAlive</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Amount of alive module instances. </p>

<p class="definition">Definition at line <a class="el" href="../../d7/d7f/_a_e_module_base_8hpp_source.html#l00109">109</a> of file <a class="el" href="../../d7/d7f/_a_e_module_base_8hpp_source.html">AEModuleBase.hpp</a>.</p>

</div>
</div>
<a id="a230f2b4ee8b95592fee2a627e0412c7d" name="a230f2b4ee8b95592fee2a627e0412c7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a230f2b4ee8b95592fee2a627e0412c7d">&#9670;&#160;</a></span>m_vecEntryIndices</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="../../db/d7b/struct_a_e_log_entry_info.html">AELogEntryInfo</a>&gt; AELogParser::m_vecEntryIndices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The list of all indexed <em>valid</em> entries in the log file. </p>
<p>Each item contains their corresponding cursor position in the file and their type/severity. </p>

<p class="definition">Definition at line <a class="el" href="../../d0/dab/_a_e_log_parser_8hpp_source.html#l00545">545</a> of file <a class="el" href="../../d0/dab/_a_e_log_parser_8hpp_source.html">AELogParser.hpp</a>.</p>

</div>
</div>
<a id="aafdf325ac835c82df04ce2d327f820c8" name="aafdf325ac835c82df04ce2d327f820c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafdf325ac835c82df04ce2d327f820c8">&#9670;&#160;</a></span>m_vecInvalidEntryIndices</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="../../dc/d89/_a_e_typedefs_8hpp.html#a01c88e5c03ebee098af42984516b9aaf">llint</a>&gt; AELogParser::m_vecInvalidEntryIndices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The list of all indexed <em>invalid</em> entries in the log file Each item contains their corresponding cursor position in the file. </p>

<p class="definition">Definition at line <a class="el" href="../../d0/dab/_a_e_log_parser_8hpp_source.html#l00548">548</a> of file <a class="el" href="../../d0/dab/_a_e_log_parser_8hpp_source.html">AELogParser.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>AELogParser/include/<a class="el" href="../../d0/dab/_a_e_log_parser_8hpp_source.html">AELogParser.hpp</a></li>
<li>AELogParser/src/<a class="el" href="../../d2/d77/_a_e_log_parser_8cpp_source.html">AELogParser.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../d8/d52/class_a_e_log_parser.html">AELogParser</a></li>
    <li class="footer">Generated on Thu Feb 29 2024 21:13:54 for ArtyK&#39;s Console Engine by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0 </li>
  </ul>
</div>
</body>
</html>
